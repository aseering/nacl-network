diff -uNr binutils-2.19.51.20090622.orig/binutils/arlex.c binutils-2.19.51.20090622/binutils/arlex.c
--- binutils-2.19.51.20090622.orig/binutils/arlex.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.19.51.20090622/binutils/arlex.c	2009-06-28 17:16:42.000000000 +0200
@@ -0,0 +1,2086 @@
+
+#line 3 "arlex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 40
+#define YY_END_OF_BUFFER 41
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[177] =
+    {   0,
+        0,    0,   41,   40,   39,   38,   35,   32,   33,   36,
+       40,   34,   37,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   36,   31,   37,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,    7,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   22,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+
+       35,   35,   35,   10,   11,   12,   35,   15,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   25,   26,   27,
+       35,   30,   35,   35,   35,    3,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   18,   35,   35,   35,   35,
+       35,   35,   35,    1,    2,    4,    5,   35,   35,   35,
+       35,   35,   16,   17,   19,   20,   35,   35,   35,   35,
+       35,   35,    8,    9,   13,   14,   35,   23,   24,   28,
+       29,   35,   35,    6,   21,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    1,    1,    4,    1,    1,    1,    5,
+        6,    7,    8,    9,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,   10,    1,
+        1,    1,    1,    1,   11,   12,   13,   14,   15,   16,
+        4,   17,   18,    4,    4,   19,   20,   21,   22,   23,
+        4,   24,   25,   26,   27,   28,    4,   29,   30,    4,
+        1,    4,    1,    1,    4,    1,   31,   32,   33,   34,
+
+       35,   36,    4,   37,   38,    4,    4,   39,   40,   41,
+       42,   43,    4,   44,   45,   46,   47,   48,    4,   49,
+       50,    4,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[51] =
+    {   0,
+        1,    2,    1,    3,    1,    1,    1,    1,    1,    1,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3
+    } ;
+
+static yyconst flex_int16_t yy_base[180] =
+    {   0,
+        0,    0,  193,  194,  194,  194,    0,  194,  194,    0,
+      190,  194,    0,  177,   32,   37,   32,  163,  174,  170,
+      164,  171,  174,  169,  149,   15,   22,   17,  135,  146,
+      142,  136,  143,  146,  141,    0,    0,  194,    0,  161,
+      159,  158,  153,  147,  156,  143,  149,  148,  141,  150,
+      141,  135,  138,  127,  125,  124,  119,  113,  122,  109,
+      115,  114,  107,  116,  107,  101,  104,   43,  136,  135,
+      130,  129,    0,  119,  123,  118,  114,  118,  119,  122,
+      124,   25,  104,  103,   98,   97,    0,   87,   91,   86,
+       82,   86,   87,   90,   92,  105,  100,   97,   94,   93,
+
+      105,  106,  102,    0,    0,    0,  104,    0,   92,   75,
+       70,   67,   64,   63,   75,   76,   72,    0,    0,    0,
+       74,    0,   62,   91,   88,    0,   86,   85,   73,   85,
+       79,   83,   70,   62,   59,    0,   57,   56,   44,   56,
+       50,   54,   41,    0,    0,    0,    0,   63,   58,   59,
+       67,   66,    0,    0,    0,    0,   38,   33,   34,   42,
+       41,   51,    0,    0,    0,    0,   30,    0,    0,    0,
+        0,   43,   21,    0,    0,  194,   65,   66,   69
+    } ;
+
+static yyconst flex_int16_t yy_def[180] =
+    {   0,
+      176,    1,  176,  176,  176,  176,  177,  176,  176,  178,
+      176,  176,  179,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  178,  176,  179,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,    0,  176,  176,  176
+    } ;
+
+static yyconst flex_int16_t yy_nxt[245] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,    7,   15,   16,   17,   18,   19,    7,   20,    7,
+        7,   21,    7,   22,   23,    7,    7,   24,    7,    7,
+       25,    7,   26,   27,   28,   29,   30,    7,   31,    7,
+        7,   32,    7,   33,   34,    7,    7,   35,    7,    7,
+       41,   43,   45,   55,   44,   42,   57,   59,   56,   58,
+       46,   96,   97,  110,  111,   60,   37,   36,   37,   39,
+      175,   39,  174,  173,  172,  171,  170,  169,  168,  167,
+      166,  165,  164,  163,  162,  161,  160,  159,  158,  157,
+      156,  155,  154,  153,  152,  151,  150,  149,  148,  147,
+
+      146,  145,  144,  143,  142,  141,  140,  139,  138,  137,
+      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
+      126,  125,  124,  123,  122,  121,  120,  119,  118,  117,
+      116,  115,  114,  113,  112,  109,  108,  107,  106,  105,
+      104,  103,  102,  101,  100,   99,   98,   95,   94,   93,
+       92,   91,   90,   89,   88,   87,   86,   85,   84,   83,
+       82,   81,   80,   79,   78,   77,   76,   75,   74,   73,
+       72,   71,   70,   69,   68,   67,   66,   65,   64,   63,
+       62,   61,   54,   53,   52,   51,   50,   49,   48,   47,
+       40,   38,  176,    3,  176,  176,  176,  176,  176,  176,
+
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176
+    } ;
+
+static yyconst flex_int16_t yy_chk[245] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+       15,   16,   17,   26,   16,   15,   27,   28,   26,   27,
+       17,   68,   68,   82,   82,   28,  178,  177,  178,  179,
+      173,  179,  172,  167,  162,  161,  160,  159,  158,  157,
+      152,  151,  150,  149,  148,  143,  142,  141,  140,  139,
+      138,  137,  135,  134,  133,  132,  131,  130,  129,  128,
+
+      127,  125,  124,  123,  121,  117,  116,  115,  114,  113,
+      112,  111,  110,  109,  107,  103,  102,  101,  100,   99,
+       98,   97,   96,   95,   94,   93,   92,   91,   90,   89,
+       88,   86,   85,   84,   83,   81,   80,   79,   78,   77,
+       76,   75,   74,   72,   71,   70,   69,   67,   66,   65,
+       64,   63,   62,   61,   60,   59,   58,   57,   56,   55,
+       54,   53,   52,   51,   50,   49,   48,   47,   46,   45,
+       44,   43,   42,   41,   40,   35,   34,   33,   32,   31,
+       30,   29,   25,   24,   23,   22,   21,   20,   19,   18,
+       14,   11,    3,  176,  176,  176,  176,  176,  176,  176,
+
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "arlex.l"
+#line 2 "arlex.l"
+/* arlex.l - Strange script language lexer */
+
+/* Copyright 1992, 1997, 2000, 2001, 2002, 2003, 2004, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Contributed by Steve Chamberlain <sac@cygnus.com>.  */
+
+#define DONTDECLARE_MALLOC
+#include "ansidecl.h"
+#include "libiberty.h"
+#include "arparse.h"
+
+#define YY_NO_UNPUT
+
+extern int yylex (void);
+
+int linenumber;
+#line 604 "arlex.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 42 "arlex.l"
+
+
+#line 794 "arlex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 177 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 194 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 44 "arlex.l"
+{ return ADDLIB; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 45 "arlex.l"
+{ return ADDMOD; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 46 "arlex.l"
+{ return CLEAR; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 47 "arlex.l"
+{ return CREATE; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 48 "arlex.l"
+{ return DELETE; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 49 "arlex.l"
+{ return DIRECTORY; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 50 "arlex.l"
+{ return END; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 51 "arlex.l"
+{ return EXTRACT; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 52 "arlex.l"
+{ return FULLDIR; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 53 "arlex.l"
+{ return HELP; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 54 "arlex.l"
+{ return LIST; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 55 "arlex.l"
+{ return OPEN; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 56 "arlex.l"
+{ return REPLACE; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 57 "arlex.l"
+{ return VERBOSE; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 58 "arlex.l"
+{ return SAVE; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 59 "arlex.l"
+{ return ADDLIB; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 60 "arlex.l"
+{ return ADDMOD; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 61 "arlex.l"
+{ return CLEAR; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 62 "arlex.l"
+{ return CREATE; }
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 63 "arlex.l"
+{ return DELETE; }
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 64 "arlex.l"
+{ return DIRECTORY; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 65 "arlex.l"
+{ return END; }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 66 "arlex.l"
+{ return EXTRACT; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 67 "arlex.l"
+{ return FULLDIR; }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 68 "arlex.l"
+{ return HELP; }
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 69 "arlex.l"
+{ return LIST; }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 70 "arlex.l"
+{ return OPEN; }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 71 "arlex.l"
+{ return REPLACE; }
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 72 "arlex.l"
+{ return VERBOSE; }
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 73 "arlex.l"
+{ return SAVE; }
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+#line 74 "arlex.l"
+{ linenumber ++; }
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 75 "arlex.l"
+{ return '('; }
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 76 "arlex.l"
+{ return ')'; }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 77 "arlex.l"
+{ return ','; }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 78 "arlex.l"
+{ 	
+		yylval.name =  xstrdup (yytext);
+		return FILENAME;
+		}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 82 "arlex.l"
+{ }
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 83 "arlex.l"
+{ }
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 84 "arlex.l"
+{ }
+	YY_BREAK
+case 39:
+/* rule 39 can match eol */
+YY_RULE_SETUP
+#line 85 "arlex.l"
+{ linenumber ++; return NEWLINE; }	
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 87 "arlex.l"
+ECHO;
+	YY_BREAK
+#line 1082 "arlex.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 177 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 177 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 176);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 87 "arlex.l"
+
+
+#ifndef yywrap
+/* Needed for lex, though not flex. */
+int yywrap(void) { return 1; }
+#endif
+
diff -uNr binutils-2.19.51.20090622.orig/binutils/arparse.c binutils-2.19.51.20090622/binutils/arparse.c
--- binutils-2.19.51.20090622.orig/binutils/arparse.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.19.51.20090622/binutils/arparse.c	2009-06-28 17:16:42.000000000 +0200
@@ -0,0 +1,1825 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 1 "arparse.y"
+
+/* arparse.y - Stange script language parser */
+
+/* Copyright 1992, 1993, 1995, 1997, 1999, 2002, 2003, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Contributed by Steve Chamberlain
+   		  sac@cygnus.com
+
+*/
+#define DONTDECLARE_MALLOC
+#include "sysdep.h"
+#include "bfd.h"
+#include "arsup.h"
+extern int verbose;
+extern int yylex (void);
+static int yyerror (const char *);
+
+
+/* Line 189 of yacc.c  */
+#line 111 "arparse.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NEWLINE = 258,
+     VERBOSE = 259,
+     FILENAME = 260,
+     ADDLIB = 261,
+     LIST = 262,
+     ADDMOD = 263,
+     CLEAR = 264,
+     CREATE = 265,
+     DELETE = 266,
+     DIRECTORY = 267,
+     END = 268,
+     EXTRACT = 269,
+     FULLDIR = 270,
+     HELP = 271,
+     QUIT = 272,
+     REPLACE = 273,
+     SAVE = 274,
+     OPEN = 275
+   };
+#endif
+/* Tokens.  */
+#define NEWLINE 258
+#define VERBOSE 259
+#define FILENAME 260
+#define ADDLIB 261
+#define LIST 262
+#define ADDMOD 263
+#define CLEAR 264
+#define CREATE 265
+#define DELETE 266
+#define DIRECTORY 267
+#define END 268
+#define EXTRACT 269
+#define FULLDIR 270
+#define HELP 271
+#define QUIT 272
+#define REPLACE 273
+#define SAVE 274
+#define OPEN 275
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 38 "arparse.y"
+
+  char *name;
+struct list *list ;
+
+
+
+
+/* Line 214 of yacc.c  */
+#line 195 "arparse.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 207 "arparse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   34
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  24
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  22
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  42
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  53
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   275
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      21,    22,     2,     2,    23,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     7,    10,    11,    14,    16,    18,
+      20,    22,    24,    26,    28,    30,    32,    34,    36,    38,
+      40,    42,    44,    45,    48,    51,    53,    56,    59,    61,
+      63,    66,    69,    73,    78,    80,    81,    85,    86,    90,
+      91,    93,    94
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      25,     0,    -1,    -1,    26,    27,    -1,    27,    28,    -1,
+      -1,    29,     3,    -1,    37,    -1,    38,    -1,    45,    -1,
+      40,    -1,    39,    -1,    32,    -1,    34,    -1,    36,    -1,
+      30,    -1,    31,    -1,    33,    -1,    35,    -1,    13,    -1,
+       1,    -1,     5,    -1,    -1,    14,    43,    -1,    18,    43,
+      -1,     9,    -1,    11,    43,    -1,     8,    43,    -1,     7,
+      -1,    19,    -1,    20,     5,    -1,    10,     5,    -1,     6,
+       5,    42,    -1,    12,     5,    42,    41,    -1,     5,    -1,
+      -1,    21,    43,    22,    -1,    -1,    43,    44,     5,    -1,
+      -1,    23,    -1,    -1,     4,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    69,    69,    69,    73,    74,    78,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,   102,   107,   112,   117,   121,   126,   131,
+     138,   143,   149,   153,   160,   162,   166,   169,   173,   179,
+     184,   185,   190
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NEWLINE", "VERBOSE", "FILENAME",
+  "ADDLIB", "LIST", "ADDMOD", "CLEAR", "CREATE", "DELETE", "DIRECTORY",
+  "END", "EXTRACT", "FULLDIR", "HELP", "QUIT", "REPLACE", "SAVE", "OPEN",
+  "'('", "')'", "','", "$accept", "start", "$@1", "session",
+  "command_line", "command", "extract_command", "replace_command",
+  "clear_command", "delete_command", "addmod_command", "list_command",
+  "save_command", "open_command", "create_command", "addlib_command",
+  "directory_command", "optional_filename", "modulelist", "modulename",
+  "optcomma", "verbose_command", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,    40,    41,    44
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    24,    26,    25,    27,    27,    28,    29,    29,    29,
+      29,    29,    29,    29,    29,    29,    29,    29,    29,    29,
+      29,    29,    29,    30,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    41,    42,    42,    43,    43,
+      44,    44,    45
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     2,     0,     2,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     0,     2,     2,     1,     2,     2,     1,     1,
+       2,     2,     3,     4,     1,     0,     3,     0,     3,     0,
+       1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     5,     1,     0,    20,    42,    21,     0,    28,
+      39,    25,     0,    39,     0,    19,    39,    39,    29,     0,
+       4,     0,    15,    16,    12,    17,    13,    18,    14,     7,
+       8,    11,    10,     9,    37,    27,    31,    26,    37,    23,
+      24,    30,     6,    39,    32,    40,     0,    35,    41,    38,
+      34,    33,    36
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,     2,     4,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    51,    44,    35,
+      46,    33
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -14
+static const yytype_int8 yypact[] =
+{
+     -14,     1,   -14,   -14,     5,   -14,   -14,   -14,     2,   -14,
+     -14,   -14,    21,   -14,    22,   -14,   -14,   -14,   -14,    23,
+     -14,    26,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,
+     -14,   -14,   -14,   -14,    10,    -3,   -14,    -3,    10,    -3,
+      -3,   -14,   -14,   -14,   -14,   -14,    27,    28,    -1,   -14,
+     -14,   -14,   -14
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,
+     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,    -4,   -13,
+     -14,   -14
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -42
+static const yytype_int8 yytable[] =
+{
+      37,     3,   -41,    39,    40,    -3,     5,    34,   -22,     6,
+       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      45,    52,    45,    17,    18,    19,    36,    38,    41,    42,
+      48,    43,    49,    50,    47
+};
+
+static const yytype_uint8 yycheck[] =
+{
+      13,     0,     5,    16,    17,     0,     1,     5,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      23,    22,    23,    18,    19,    20,     5,     5,     5,     3,
+      43,    21,     5,     5,    38
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    25,    26,     0,    27,     1,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    18,    19,    20,
+      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    45,     5,    43,     5,    43,     5,    43,
+      43,     5,     3,    21,    42,    23,    44,    42,    43,     5,
+       5,    41,    22
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+
+/* Line 1455 of yacc.c  */
+#line 69 "arparse.y"
+    { prompt(); }
+    break;
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
+#line 78 "arparse.y"
+    { prompt(); }
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 94 "arparse.y"
+    { ar_end(); return 0; }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 96 "arparse.y"
+    { yyerror("foo"); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 103 "arparse.y"
+    { ar_extract((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 108 "arparse.y"
+    { ar_replace((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 113 "arparse.y"
+    { ar_clear(); }
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 118 "arparse.y"
+    { ar_delete((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 122 "arparse.y"
+    { ar_addmod((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 127 "arparse.y"
+    { ar_list(); }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 132 "arparse.y"
+    { ar_save(); }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 139 "arparse.y"
+    { ar_open((yyvsp[(2) - (2)].name),0); }
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 144 "arparse.y"
+    { ar_open((yyvsp[(2) - (2)].name),1); }
+    break;
+
+  case 32:
+
+/* Line 1455 of yacc.c  */
+#line 150 "arparse.y"
+    { ar_addlib((yyvsp[(2) - (3)].name),(yyvsp[(3) - (3)].list)); }
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 154 "arparse.y"
+    { ar_directory((yyvsp[(2) - (4)].name), (yyvsp[(3) - (4)].list), (yyvsp[(4) - (4)].name)); }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 161 "arparse.y"
+    { (yyval.name) = (yyvsp[(1) - (1)].name); }
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 162 "arparse.y"
+    { (yyval.name) = 0; }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 167 "arparse.y"
+    { (yyval.list) = (yyvsp[(2) - (3)].list); }
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 169 "arparse.y"
+    { (yyval.list) = 0; }
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 174 "arparse.y"
+    { 	struct list *n  = (struct list *) malloc(sizeof(struct list));
+			n->next = (yyvsp[(1) - (3)].list); 
+			n->name = (yyvsp[(3) - (3)].name);
+			(yyval.list) = n;
+		 }
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 179 "arparse.y"
+    { (yyval.list) = 0; }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 191 "arparse.y"
+    { verbose = !verbose; }
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 1603 "arparse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 195 "arparse.y"
+
+
+static int
+yyerror (const char *x ATTRIBUTE_UNUSED)
+{
+  extern int linenumber;
+
+  printf (_("Syntax error in archive script, line %d\n"), linenumber + 1);
+  return 0;
+}
+
diff -uNr binutils-2.19.51.20090622.orig/binutils/arparse.h binutils-2.19.51.20090622/binutils/arparse.h
--- binutils-2.19.51.20090622.orig/binutils/arparse.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.19.51.20090622/binutils/arparse.h	2009-06-28 17:16:42.000000000 +0200
@@ -0,0 +1,108 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NEWLINE = 258,
+     VERBOSE = 259,
+     FILENAME = 260,
+     ADDLIB = 261,
+     LIST = 262,
+     ADDMOD = 263,
+     CLEAR = 264,
+     CREATE = 265,
+     DELETE = 266,
+     DIRECTORY = 267,
+     END = 268,
+     EXTRACT = 269,
+     FULLDIR = 270,
+     HELP = 271,
+     QUIT = 272,
+     REPLACE = 273,
+     SAVE = 274,
+     OPEN = 275
+   };
+#endif
+/* Tokens.  */
+#define NEWLINE 258
+#define VERBOSE 259
+#define FILENAME 260
+#define ADDLIB 261
+#define LIST 262
+#define ADDMOD 263
+#define CLEAR 264
+#define CREATE 265
+#define DELETE 266
+#define DIRECTORY 267
+#define END 268
+#define EXTRACT 269
+#define FULLDIR 270
+#define HELP 271
+#define QUIT 272
+#define REPLACE 273
+#define SAVE 274
+#define OPEN 275
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 38 "arparse.y"
+
+  char *name;
+struct list *list ;
+
+
+
+
+/* Line 1676 of yacc.c  */
+#line 100 "arparse.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
diff -uNr binutils-2.19.51.20090622.orig/ld/ldgram.c binutils-2.19.51.20090622/ld/ldgram.c
--- binutils-2.19.51.20090622.orig/ld/ldgram.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.19.51.20090622/ld/ldgram.c	2009-06-28 17:16:42.000000000 +0200
@@ -0,0 +1,5092 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 23 "ldgram.y"
+
+/*
+
+ */
+
+#define DONTDECLARE_MALLOC
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "ld.h"
+#include "ldexp.h"
+#include "ldver.h"
+#include "ldlang.h"
+#include "ldfile.h"
+#include "ldemul.h"
+#include "ldmisc.h"
+#include "ldmain.h"
+#include "mri.h"
+#include "ldctor.h"
+#include "ldlex.h"
+
+#ifndef YYDEBUG
+#define YYDEBUG 1
+#endif
+
+static enum section_type sectype;
+static lang_memory_region_type *region;
+
+bfd_boolean ldgram_had_keep = FALSE;
+char *ldgram_vers_current_lang = NULL;
+
+#define ERROR_NAME_MAX 20
+static char *error_names[ERROR_NAME_MAX];
+static int error_index;
+#define PUSH_ERROR(x) if (error_index < ERROR_NAME_MAX) error_names[error_index] = x; error_index++;
+#define POP_ERROR()   error_index--;
+
+
+/* Line 189 of yacc.c  */
+#line 113 "ldgram.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     INT = 258,
+     NAME = 259,
+     LNAME = 260,
+     OREQ = 261,
+     ANDEQ = 262,
+     RSHIFTEQ = 263,
+     LSHIFTEQ = 264,
+     DIVEQ = 265,
+     MULTEQ = 266,
+     MINUSEQ = 267,
+     PLUSEQ = 268,
+     OROR = 269,
+     ANDAND = 270,
+     NE = 271,
+     EQ = 272,
+     GE = 273,
+     LE = 274,
+     RSHIFT = 275,
+     LSHIFT = 276,
+     UNARY = 277,
+     END = 278,
+     ALIGN_K = 279,
+     BLOCK = 280,
+     BIND = 281,
+     QUAD = 282,
+     SQUAD = 283,
+     LONG = 284,
+     SHORT = 285,
+     BYTE = 286,
+     SECTIONS = 287,
+     PHDRS = 288,
+     INSERT_K = 289,
+     AFTER = 290,
+     BEFORE = 291,
+     DATA_SEGMENT_ALIGN = 292,
+     DATA_SEGMENT_RELRO_END = 293,
+     DATA_SEGMENT_END = 294,
+     SORT_BY_NAME = 295,
+     SORT_BY_ALIGNMENT = 296,
+     SIZEOF_HEADERS = 297,
+     OUTPUT_FORMAT = 298,
+     FORCE_COMMON_ALLOCATION = 299,
+     OUTPUT_ARCH = 300,
+     INHIBIT_COMMON_ALLOCATION = 301,
+     SEGMENT_START = 302,
+     INCLUDE = 303,
+     MEMORY = 304,
+     REGION_ALIAS = 305,
+     NOLOAD = 306,
+     DSECT = 307,
+     COPY = 308,
+     INFO = 309,
+     OVERLAY = 310,
+     DEFINED = 311,
+     TARGET_K = 312,
+     SEARCH_DIR = 313,
+     MAP = 314,
+     ENTRY = 315,
+     NEXT = 316,
+     SIZEOF = 317,
+     ALIGNOF = 318,
+     ADDR = 319,
+     LOADADDR = 320,
+     MAX_K = 321,
+     MIN_K = 322,
+     CEILP2 = 323,
+     NACL_MASK = 324,
+     STARTUP = 325,
+     HLL = 326,
+     SYSLIB = 327,
+     FLOAT = 328,
+     NOFLOAT = 329,
+     NOCROSSREFS = 330,
+     ORIGIN = 331,
+     FILL = 332,
+     LENGTH = 333,
+     CREATE_OBJECT_SYMBOLS = 334,
+     INPUT = 335,
+     GROUP = 336,
+     OUTPUT = 337,
+     CONSTRUCTORS = 338,
+     ALIGNMOD = 339,
+     AT = 340,
+     SUBALIGN = 341,
+     PROVIDE = 342,
+     PROVIDE_HIDDEN = 343,
+     AS_NEEDED = 344,
+     CHIP = 345,
+     LIST = 346,
+     SECT = 347,
+     ABSOLUTE = 348,
+     LOAD = 349,
+     NEWLINE = 350,
+     ENDWORD = 351,
+     ORDER = 352,
+     NAMEWORD = 353,
+     ASSERT_K = 354,
+     FORMAT = 355,
+     PUBLIC = 356,
+     DEFSYMEND = 357,
+     BASE = 358,
+     ALIAS = 359,
+     TRUNCATE = 360,
+     REL = 361,
+     INPUT_SCRIPT = 362,
+     INPUT_MRI_SCRIPT = 363,
+     INPUT_DEFSYM = 364,
+     CASE = 365,
+     EXTERN = 366,
+     START = 367,
+     VERS_TAG = 368,
+     VERS_IDENTIFIER = 369,
+     GLOBAL = 370,
+     LOCAL = 371,
+     VERSIONK = 372,
+     INPUT_VERSION_SCRIPT = 373,
+     KEEP = 374,
+     ONLY_IF_RO = 375,
+     ONLY_IF_RW = 376,
+     SPECIAL = 377,
+     EXCLUDE_FILE = 378,
+     CONSTANT = 379,
+     INPUT_DYNAMIC_LIST = 380
+   };
+#endif
+/* Tokens.  */
+#define INT 258
+#define NAME 259
+#define LNAME 260
+#define OREQ 261
+#define ANDEQ 262
+#define RSHIFTEQ 263
+#define LSHIFTEQ 264
+#define DIVEQ 265
+#define MULTEQ 266
+#define MINUSEQ 267
+#define PLUSEQ 268
+#define OROR 269
+#define ANDAND 270
+#define NE 271
+#define EQ 272
+#define GE 273
+#define LE 274
+#define RSHIFT 275
+#define LSHIFT 276
+#define UNARY 277
+#define END 278
+#define ALIGN_K 279
+#define BLOCK 280
+#define BIND 281
+#define QUAD 282
+#define SQUAD 283
+#define LONG 284
+#define SHORT 285
+#define BYTE 286
+#define SECTIONS 287
+#define PHDRS 288
+#define INSERT_K 289
+#define AFTER 290
+#define BEFORE 291
+#define DATA_SEGMENT_ALIGN 292
+#define DATA_SEGMENT_RELRO_END 293
+#define DATA_SEGMENT_END 294
+#define SORT_BY_NAME 295
+#define SORT_BY_ALIGNMENT 296
+#define SIZEOF_HEADERS 297
+#define OUTPUT_FORMAT 298
+#define FORCE_COMMON_ALLOCATION 299
+#define OUTPUT_ARCH 300
+#define INHIBIT_COMMON_ALLOCATION 301
+#define SEGMENT_START 302
+#define INCLUDE 303
+#define MEMORY 304
+#define REGION_ALIAS 305
+#define NOLOAD 306
+#define DSECT 307
+#define COPY 308
+#define INFO 309
+#define OVERLAY 310
+#define DEFINED 311
+#define TARGET_K 312
+#define SEARCH_DIR 313
+#define MAP 314
+#define ENTRY 315
+#define NEXT 316
+#define SIZEOF 317
+#define ALIGNOF 318
+#define ADDR 319
+#define LOADADDR 320
+#define MAX_K 321
+#define MIN_K 322
+#define CEILP2 323
+#define NACL_MASK 324
+#define STARTUP 325
+#define HLL 326
+#define SYSLIB 327
+#define FLOAT 328
+#define NOFLOAT 329
+#define NOCROSSREFS 330
+#define ORIGIN 331
+#define FILL 332
+#define LENGTH 333
+#define CREATE_OBJECT_SYMBOLS 334
+#define INPUT 335
+#define GROUP 336
+#define OUTPUT 337
+#define CONSTRUCTORS 338
+#define ALIGNMOD 339
+#define AT 340
+#define SUBALIGN 341
+#define PROVIDE 342
+#define PROVIDE_HIDDEN 343
+#define AS_NEEDED 344
+#define CHIP 345
+#define LIST 346
+#define SECT 347
+#define ABSOLUTE 348
+#define LOAD 349
+#define NEWLINE 350
+#define ENDWORD 351
+#define ORDER 352
+#define NAMEWORD 353
+#define ASSERT_K 354
+#define FORMAT 355
+#define PUBLIC 356
+#define DEFSYMEND 357
+#define BASE 358
+#define ALIAS 359
+#define TRUNCATE 360
+#define REL 361
+#define INPUT_SCRIPT 362
+#define INPUT_MRI_SCRIPT 363
+#define INPUT_DEFSYM 364
+#define CASE 365
+#define EXTERN 366
+#define START 367
+#define VERS_TAG 368
+#define VERS_IDENTIFIER 369
+#define GLOBAL 370
+#define LOCAL 371
+#define VERSIONK 372
+#define INPUT_VERSION_SCRIPT 373
+#define KEEP 374
+#define ONLY_IF_RO 375
+#define ONLY_IF_RW 376
+#define SPECIAL 377
+#define EXCLUDE_FILE 378
+#define CONSTANT 379
+#define INPUT_DYNAMIC_LIST 380
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 61 "ldgram.y"
+
+  bfd_vma integer;
+  struct big_int
+    {
+      bfd_vma integer;
+      char *str;
+    } bigint;
+  fill_type *fill;
+  char *name;
+  const char *cname;
+  struct wildcard_spec wildcard;
+  struct wildcard_list *wildcard_list;
+  struct name_list *name_list;
+  int token;
+  union etree_union *etree;
+  struct phdr_info
+    {
+      bfd_boolean filehdr;
+      bfd_boolean phdrs;
+      union etree_union *at;
+      union etree_union *flags;
+    } phdr;
+  struct lang_nocrossref *nocrossref;
+  struct lang_output_section_phdr_list *section_phdr;
+  struct bfd_elf_version_deps *deflist;
+  struct bfd_elf_version_expr *versyms;
+  struct bfd_elf_version_tree *versnode;
+
+
+
+/* Line 214 of yacc.c  */
+#line 430 "ldgram.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 442 "ldgram.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  17
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   1860
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  149
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  126
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  358
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  771
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   380
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,   147,     2,     2,     2,    34,    21,     2,
+      37,   144,    32,    30,   142,    31,     2,    33,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    16,   143,
+      24,     6,    25,    15,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,   145,     2,   146,    20,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    56,    19,    57,   148,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     7,     8,     9,    10,    11,    12,    13,    14,    17,
+      18,    22,    23,    26,    27,    28,    29,    35,    36,    38,
+      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
+      49,    50,    51,    52,    53,    54,    55,    58,    59,    60,
+      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
+      71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
+      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
+     101,   102,   103,   104,   105,   106,   107,   108,   109,   110,
+     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
+     121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
+     141
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     9,    12,    15,    18,    20,    21,
+      26,    27,    30,    34,    35,    38,    43,    45,    47,    50,
+      52,    57,    62,    66,    69,    74,    78,    83,    88,    93,
+      98,   103,   106,   109,   112,   117,   122,   125,   128,   131,
+     134,   135,   141,   144,   145,   149,   152,   153,   155,   159,
+     161,   165,   166,   168,   172,   173,   176,   178,   181,   185,
+     186,   189,   192,   193,   195,   197,   199,   201,   203,   205,
+     207,   209,   211,   213,   218,   223,   228,   233,   242,   247,
+     249,   251,   256,   257,   263,   268,   269,   275,   280,   285,
+     289,   293,   300,   302,   306,   309,   311,   315,   318,   319,
+     325,   326,   334,   335,   342,   347,   350,   353,   354,   359,
+     362,   363,   371,   373,   375,   377,   379,   385,   390,   395,
+     403,   411,   419,   427,   436,   439,   441,   445,   447,   449,
+     453,   458,   460,   461,   467,   470,   472,   474,   476,   481,
+     483,   488,   493,   494,   503,   504,   510,   513,   515,   516,
+     518,   520,   522,   524,   526,   528,   530,   533,   534,   536,
+     538,   540,   542,   544,   546,   548,   550,   552,   554,   558,
+     562,   569,   576,   578,   579,   584,   586,   587,   591,   593,
+     594,   602,   603,   609,   613,   617,   618,   622,   624,   627,
+     629,   632,   637,   642,   646,   650,   652,   657,   661,   662,
+     664,   666,   667,   670,   674,   675,   678,   681,   685,   690,
+     693,   696,   699,   703,   707,   711,   715,   719,   723,   727,
+     731,   735,   739,   743,   747,   751,   755,   759,   763,   769,
+     773,   777,   782,   784,   786,   791,   796,   801,   806,   811,
+     816,   821,   828,   835,   842,   847,   854,   859,   861,   868,
+     875,   880,   885,   892,   897,   902,   906,   907,   912,   913,
+     918,   919,   924,   925,   927,   929,   931,   932,   933,   934,
+     935,   936,   937,   957,   958,   959,   960,   961,   962,   981,
+     982,   983,   991,   992,   998,  1000,  1002,  1004,  1006,  1008,
+    1012,  1013,  1016,  1020,  1023,  1030,  1041,  1044,  1046,  1047,
+    1049,  1052,  1053,  1054,  1058,  1059,  1060,  1061,  1062,  1074,
+    1079,  1080,  1083,  1084,  1085,  1092,  1094,  1095,  1099,  1105,
+    1106,  1110,  1111,  1114,  1116,  1119,  1124,  1127,  1128,  1131,
+    1132,  1138,  1140,  1143,  1148,  1154,  1161,  1163,  1166,  1167,
+    1170,  1175,  1180,  1189,  1191,  1193,  1197,  1201,  1202,  1212,
+    1213,  1221,  1223,  1227,  1229,  1233,  1235,  1239,  1240
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     150,     0,    -1,   123,   166,    -1,   124,   154,    -1,   134,
+     263,    -1,   141,   258,    -1,   125,   152,    -1,     4,    -1,
+      -1,   153,     4,     6,   219,    -1,    -1,   155,   156,    -1,
+     156,   157,   111,    -1,    -1,   106,   219,    -1,   106,   219,
+     142,   219,    -1,     4,    -1,   107,    -1,   113,   159,    -1,
+     112,    -1,   117,     4,     6,   219,    -1,   117,     4,   142,
+     219,    -1,   117,     4,   219,    -1,   116,     4,    -1,   108,
+       4,   142,   219,    -1,   108,     4,   219,    -1,   108,     4,
+       6,   219,    -1,    38,     4,     6,   219,    -1,    38,     4,
+     142,   219,    -1,   100,     4,     6,   219,    -1,   100,     4,
+     142,   219,    -1,   109,   161,    -1,   110,   160,    -1,   114,
+       4,    -1,   120,     4,   142,     4,    -1,   120,     4,   142,
+       3,    -1,   119,   219,    -1,   121,     3,    -1,   126,   162,
+      -1,   127,   163,    -1,    -1,    64,   151,   158,   156,    36,
+      -1,   128,     4,    -1,    -1,   159,   142,     4,    -1,   159,
+       4,    -1,    -1,     4,    -1,   160,   142,     4,    -1,     4,
+      -1,   161,   142,     4,    -1,    -1,     4,    -1,   162,   142,
+       4,    -1,    -1,   164,   165,    -1,     4,    -1,   165,     4,
+      -1,   165,   142,     4,    -1,    -1,   167,   168,    -1,   168,
+     169,    -1,    -1,   199,    -1,   176,    -1,   250,    -1,   210,
+      -1,   211,    -1,   213,    -1,   215,    -1,   178,    -1,   265,
+      -1,   143,    -1,    73,    37,     4,   144,    -1,    74,    37,
+     151,   144,    -1,    98,    37,   151,   144,    -1,    59,    37,
+       4,   144,    -1,    59,    37,     4,   142,     4,   142,     4,
+     144,    -1,    61,    37,     4,   144,    -1,    60,    -1,    62,
+      -1,    96,    37,   172,   144,    -1,    -1,    97,   170,    37,
+     172,   144,    -1,    75,    37,   151,   144,    -1,    -1,    64,
+     151,   171,   168,    36,    -1,    91,    37,   216,   144,    -1,
+     127,    37,   163,   144,    -1,    48,    49,     4,    -1,    48,
+      50,     4,    -1,    66,    37,     4,   142,     4,   144,    -1,
+       4,    -1,   172,   142,     4,    -1,   172,     4,    -1,     5,
+      -1,   172,   142,     5,    -1,   172,     5,    -1,    -1,   105,
+      37,   173,   172,   144,    -1,    -1,   172,   142,   105,    37,
+     174,   172,   144,    -1,    -1,   172,   105,    37,   175,   172,
+     144,    -1,    46,    56,   177,    57,    -1,   177,   225,    -1,
+     177,   178,    -1,    -1,    76,    37,     4,   144,    -1,   197,
+     196,    -1,    -1,   115,   179,    37,   219,   142,     4,   144,
+      -1,     4,    -1,    32,    -1,    15,    -1,   180,    -1,   139,
+      37,   182,   144,   180,    -1,    54,    37,   180,   144,    -1,
+      55,    37,   180,   144,    -1,    54,    37,    55,    37,   180,
+     144,   144,    -1,    54,    37,    54,    37,   180,   144,   144,
+      -1,    55,    37,    54,    37,   180,   144,   144,    -1,    55,
+      37,    55,    37,   180,   144,   144,    -1,    54,    37,   139,
+      37,   182,   144,   180,   144,    -1,   182,   180,    -1,   180,
+      -1,   183,   198,   181,    -1,   181,    -1,     4,    -1,   145,
+     183,   146,    -1,   181,    37,   183,   144,    -1,   184,    -1,
+      -1,   135,    37,   186,   184,   144,    -1,   197,   196,    -1,
+      95,    -1,   143,    -1,    99,    -1,    54,    37,    99,   144,
+      -1,   185,    -1,   192,    37,   217,   144,    -1,    93,    37,
+     193,   144,    -1,    -1,   115,   188,    37,   219,   142,     4,
+     144,   196,    -1,    -1,    64,   151,   189,   191,    36,    -1,
+     190,   187,    -1,   187,    -1,    -1,   190,    -1,    41,    -1,
+      42,    -1,    43,    -1,    44,    -1,    45,    -1,   217,    -1,
+       6,   193,    -1,    -1,    14,    -1,    13,    -1,    12,    -1,
+      11,    -1,    10,    -1,     9,    -1,     8,    -1,     7,    -1,
+     143,    -1,   142,    -1,     4,     6,   217,    -1,     4,   195,
+     217,    -1,   103,    37,     4,     6,   217,   144,    -1,   104,
+      37,     4,     6,   217,   144,    -1,   142,    -1,    -1,    65,
+      56,   200,    57,    -1,   201,    -1,    -1,   201,   198,   202,
+      -1,   202,    -1,    -1,     4,   203,   207,    16,   205,   198,
+     206,    -1,    -1,    64,   151,   204,   200,    36,    -1,    92,
+       6,   217,    -1,    94,     6,   217,    -1,    -1,    37,   208,
+     144,    -1,   209,    -1,   208,   209,    -1,     4,    -1,   147,
+       4,    -1,    86,    37,   151,   144,    -1,    87,    37,   212,
+     144,    -1,    87,    37,   144,    -1,   212,   198,   151,    -1,
+     151,    -1,    88,    37,   214,   144,    -1,   214,   198,   151,
+      -1,    -1,    89,    -1,    90,    -1,    -1,     4,   216,    -1,
+       4,   142,   216,    -1,    -1,   218,   219,    -1,    31,   219,
+      -1,    37,   219,   144,    -1,    77,    37,   219,   144,    -1,
+     147,   219,    -1,    30,   219,    -1,   148,   219,    -1,   219,
+      32,   219,    -1,   219,    33,   219,    -1,   219,    34,   219,
+      -1,   219,    30,   219,    -1,   219,    31,   219,    -1,   219,
+      29,   219,    -1,   219,    28,   219,    -1,   219,    23,   219,
+      -1,   219,    22,   219,    -1,   219,    27,   219,    -1,   219,
+      26,   219,    -1,   219,    24,   219,    -1,   219,    25,   219,
+      -1,   219,    21,   219,    -1,   219,    20,   219,    -1,   219,
+      19,   219,    -1,   219,    15,   219,    16,   219,    -1,   219,
+      18,   219,    -1,   219,    17,   219,    -1,    72,    37,     4,
+     144,    -1,     3,    -1,    58,    -1,    79,    37,     4,   144,
+      -1,    78,    37,     4,   144,    -1,    80,    37,     4,   144,
+      -1,    81,    37,     4,   144,    -1,   140,    37,     4,   144,
+      -1,   109,    37,   219,   144,    -1,    38,    37,   219,   144,
+      -1,    38,    37,   219,   142,   219,   144,    -1,    51,    37,
+     219,   142,   219,   144,    -1,    52,    37,   219,   142,   219,
+     144,    -1,    53,    37,   219,   144,    -1,    63,    37,     4,
+     142,   219,   144,    -1,    39,    37,   219,   144,    -1,     4,
+      -1,    82,    37,   219,   142,   219,   144,    -1,    83,    37,
+     219,   142,   219,   144,    -1,    84,    37,   219,   144,    -1,
+      85,    37,   219,   144,    -1,   115,    37,   219,   142,     4,
+     144,    -1,    92,    37,     4,   144,    -1,    94,    37,     4,
+     144,    -1,   101,    25,     4,    -1,    -1,   101,    37,   219,
+     144,    -1,    -1,    38,    37,   219,   144,    -1,    -1,   102,
+      37,   219,   144,    -1,    -1,   136,    -1,   137,    -1,   138,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,     4,   226,   241,
+     221,   222,   223,   227,   224,    56,   228,   191,    57,   229,
+     244,   220,   245,   194,   230,   198,    -1,    -1,    -1,    -1,
+      -1,    -1,    71,   231,   242,   243,   221,   223,   232,    56,
+     233,   246,    57,   234,   244,   220,   245,   194,   235,   198,
+      -1,    -1,    -1,    97,   236,   241,   237,    56,   177,    57,
+      -1,    -1,    64,   151,   238,   177,    36,    -1,    67,    -1,
+      68,    -1,    69,    -1,    70,    -1,    71,    -1,    37,   239,
+     144,    -1,    -1,    37,   144,    -1,   219,   240,    16,    -1,
+     240,    16,    -1,    40,    37,   219,   144,   240,    16,    -1,
+      40,    37,   219,   144,    39,    37,   219,   144,   240,    16,
+      -1,   219,    16,    -1,    16,    -1,    -1,    91,    -1,    25,
+       4,    -1,    -1,    -1,   245,    16,     4,    -1,    -1,    -1,
+      -1,    -1,   246,     4,   247,    56,   191,    57,   248,   245,
+     194,   249,   198,    -1,    47,    56,   251,    57,    -1,    -1,
+     251,   252,    -1,    -1,    -1,     4,   253,   255,   256,   254,
+     143,    -1,   219,    -1,    -1,     4,   257,   256,    -1,   101,
+      37,   219,   144,   256,    -1,    -1,    37,   219,   144,    -1,
+      -1,   259,   260,    -1,   261,    -1,   260,   261,    -1,    56,
+     262,    57,   143,    -1,   271,   143,    -1,    -1,   264,   267,
+      -1,    -1,   266,   133,    56,   267,    57,    -1,   268,    -1,
+     267,   268,    -1,    56,   270,    57,   143,    -1,   129,    56,
+     270,    57,   143,    -1,   129,    56,   270,    57,   269,   143,
+      -1,   129,    -1,   269,   129,    -1,    -1,   271,   143,    -1,
+     131,    16,   271,   143,    -1,   132,    16,   271,   143,    -1,
+     131,    16,   271,   143,   132,    16,   271,   143,    -1,   130,
+      -1,     4,    -1,   271,   143,   130,    -1,   271,   143,     4,
+      -1,    -1,   271,   143,   127,     4,    56,   272,   271,   274,
+      57,    -1,    -1,   127,     4,    56,   273,   271,   274,    57,
+      -1,   131,    -1,   271,   143,   131,    -1,   132,    -1,   271,
+     143,   132,    -1,   127,    -1,   271,   143,   127,    -1,    -1,
+     143,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   161,   161,   162,   163,   164,   165,   169,   173,   173,
+     183,   183,   196,   197,   201,   202,   203,   206,   209,   210,
+     211,   213,   215,   217,   219,   221,   223,   225,   227,   229,
+     231,   233,   234,   235,   237,   239,   241,   243,   245,   246,
+     248,   247,   251,   253,   257,   258,   259,   263,   265,   269,
+     271,   276,   277,   278,   283,   283,   288,   290,   292,   297,
+     297,   303,   304,   309,   310,   311,   312,   313,   314,   315,
+     316,   317,   318,   319,   321,   323,   325,   328,   330,   332,
+     334,   336,   338,   337,   341,   344,   343,   347,   351,   352,
+     354,   356,   361,   364,   367,   370,   373,   376,   380,   379,
+     384,   383,   388,   387,   394,   398,   399,   400,   404,   406,
+     407,   407,   415,   419,   423,   430,   436,   442,   448,   454,
+     460,   466,   472,   478,   487,   496,   507,   516,   527,   535,
+     539,   546,   548,   547,   554,   555,   559,   560,   565,   570,
+     571,   576,   580,   580,   584,   583,   590,   591,   594,   596,
+     600,   602,   604,   606,   608,   613,   620,   622,   626,   628,
+     630,   632,   634,   636,   638,   640,   645,   645,   650,   654,
+     662,   666,   674,   674,   678,   681,   681,   684,   685,   690,
+     689,   695,   694,   701,   709,   717,   718,   722,   723,   727,
+     729,   734,   739,   740,   745,   747,   753,   755,   757,   761,
+     763,   769,   772,   781,   792,   792,   798,   800,   802,   804,
+     806,   808,   811,   813,   815,   817,   819,   821,   823,   825,
+     827,   829,   831,   833,   835,   837,   839,   841,   843,   845,
+     847,   849,   851,   853,   856,   858,   860,   862,   864,   866,
+     868,   870,   872,   874,   876,   878,   887,   889,   891,   893,
+     895,   897,   899,   901,   903,   909,   910,   914,   915,   919,
+     920,   924,   925,   929,   930,   931,   932,   935,   939,   942,
+     948,   950,   935,   957,   959,   961,   966,   968,   956,   978,
+     980,   978,   986,   985,   992,   993,   994,   995,   996,  1000,
+    1001,  1002,  1006,  1007,  1012,  1013,  1018,  1019,  1024,  1025,
+    1030,  1032,  1037,  1040,  1053,  1057,  1062,  1064,  1055,  1072,
+    1075,  1077,  1081,  1082,  1081,  1091,  1136,  1139,  1151,  1160,
+    1163,  1170,  1170,  1182,  1183,  1187,  1191,  1200,  1200,  1214,
+    1214,  1224,  1225,  1229,  1233,  1237,  1244,  1248,  1256,  1259,
+    1263,  1267,  1271,  1278,  1282,  1286,  1290,  1295,  1294,  1308,
+    1307,  1317,  1321,  1325,  1329,  1333,  1337,  1343,  1345
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "INT", "NAME", "LNAME", "'='", "OREQ",
+  "ANDEQ", "RSHIFTEQ", "LSHIFTEQ", "DIVEQ", "MULTEQ", "MINUSEQ", "PLUSEQ",
+  "'?'", "':'", "OROR", "ANDAND", "'|'", "'^'", "'&'", "NE", "EQ", "'<'",
+  "'>'", "GE", "LE", "RSHIFT", "LSHIFT", "'+'", "'-'", "'*'", "'/'", "'%'",
+  "UNARY", "END", "'('", "ALIGN_K", "BLOCK", "BIND", "QUAD", "SQUAD",
+  "LONG", "SHORT", "BYTE", "SECTIONS", "PHDRS", "INSERT_K", "AFTER",
+  "BEFORE", "DATA_SEGMENT_ALIGN", "DATA_SEGMENT_RELRO_END",
+  "DATA_SEGMENT_END", "SORT_BY_NAME", "SORT_BY_ALIGNMENT", "'{'", "'}'",
+  "SIZEOF_HEADERS", "OUTPUT_FORMAT", "FORCE_COMMON_ALLOCATION",
+  "OUTPUT_ARCH", "INHIBIT_COMMON_ALLOCATION", "SEGMENT_START", "INCLUDE",
+  "MEMORY", "REGION_ALIAS", "NOLOAD", "DSECT", "COPY", "INFO", "OVERLAY",
+  "DEFINED", "TARGET_K", "SEARCH_DIR", "MAP", "ENTRY", "NEXT", "SIZEOF",
+  "ALIGNOF", "ADDR", "LOADADDR", "MAX_K", "MIN_K", "CEILP2", "NACL_MASK",
+  "STARTUP", "HLL", "SYSLIB", "FLOAT", "NOFLOAT", "NOCROSSREFS", "ORIGIN",
+  "FILL", "LENGTH", "CREATE_OBJECT_SYMBOLS", "INPUT", "GROUP", "OUTPUT",
+  "CONSTRUCTORS", "ALIGNMOD", "AT", "SUBALIGN", "PROVIDE",
+  "PROVIDE_HIDDEN", "AS_NEEDED", "CHIP", "LIST", "SECT", "ABSOLUTE",
+  "LOAD", "NEWLINE", "ENDWORD", "ORDER", "NAMEWORD", "ASSERT_K", "FORMAT",
+  "PUBLIC", "DEFSYMEND", "BASE", "ALIAS", "TRUNCATE", "REL",
+  "INPUT_SCRIPT", "INPUT_MRI_SCRIPT", "INPUT_DEFSYM", "CASE", "EXTERN",
+  "START", "VERS_TAG", "VERS_IDENTIFIER", "GLOBAL", "LOCAL", "VERSIONK",
+  "INPUT_VERSION_SCRIPT", "KEEP", "ONLY_IF_RO", "ONLY_IF_RW", "SPECIAL",
+  "EXCLUDE_FILE", "CONSTANT", "INPUT_DYNAMIC_LIST", "','", "';'", "')'",
+  "'['", "']'", "'!'", "'~'", "$accept", "file", "filename", "defsym_expr",
+  "$@1", "mri_script_file", "$@2", "mri_script_lines",
+  "mri_script_command", "$@3", "ordernamelist", "mri_load_name_list",
+  "mri_abs_name_list", "casesymlist", "extern_name_list", "$@4",
+  "extern_name_list_body", "script_file", "$@5", "ifile_list", "ifile_p1",
+  "$@6", "$@7", "input_list", "@8", "@9", "@10", "sections",
+  "sec_or_group_p1", "statement_anywhere", "$@11", "wildcard_name",
+  "wildcard_spec", "exclude_name_list", "file_NAME_list",
+  "input_section_spec_no_keep", "input_section_spec", "$@12", "statement",
+  "$@13", "$@14", "statement_list", "statement_list_opt", "length",
+  "fill_exp", "fill_opt", "assign_op", "end", "assignment", "opt_comma",
+  "memory", "memory_spec_list_opt", "memory_spec_list", "memory_spec",
+  "$@15", "$@16", "origin_spec", "length_spec", "attributes_opt",
+  "attributes_list", "attributes_string", "startup", "high_level_library",
+  "high_level_library_NAME_list", "low_level_library",
+  "low_level_library_NAME_list", "floating_point_support",
+  "nocrossref_list", "mustbe_exp", "$@17", "exp", "memspec_at_opt",
+  "opt_at", "opt_align", "opt_subalign", "sect_constraint", "section",
+  "$@18", "$@19", "$@20", "$@21", "$@22", "$@23", "$@24", "$@25", "$@26",
+  "$@27", "$@28", "$@29", "$@30", "type", "atype", "opt_exp_with_type",
+  "opt_exp_without_type", "opt_nocrossrefs", "memspec_opt", "phdr_opt",
+  "overlay_section", "$@31", "$@32", "$@33", "phdrs", "phdr_list", "phdr",
+  "$@34", "$@35", "phdr_type", "phdr_qualifiers", "phdr_val",
+  "dynamic_list_file", "$@36", "dynamic_list_nodes", "dynamic_list_node",
+  "dynamic_list_tag", "version_script_file", "$@37", "version", "$@38",
+  "vers_nodes", "vers_node", "verdep", "vers_tag", "vers_defns", "@39",
+  "@40", "opt_semicolon", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,    61,   261,   262,   263,
+     264,   265,   266,   267,   268,    63,    58,   269,   270,   124,
+      94,    38,   271,   272,    60,    62,   273,   274,   275,   276,
+      43,    45,    42,    47,    37,   277,   278,    40,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291,   292,   293,   294,   295,   296,   123,   125,   297,   298,
+     299,   300,   301,   302,   303,   304,   305,   306,   307,   308,
+     309,   310,   311,   312,   313,   314,   315,   316,   317,   318,
+     319,   320,   321,   322,   323,   324,   325,   326,   327,   328,
+     329,   330,   331,   332,   333,   334,   335,   336,   337,   338,
+     339,   340,   341,   342,   343,   344,   345,   346,   347,   348,
+     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
+     359,   360,   361,   362,   363,   364,   365,   366,   367,   368,
+     369,   370,   371,   372,   373,   374,   375,   376,   377,   378,
+     379,   380,    44,    59,    41,    91,    93,    33,   126
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint16 yyr1[] =
+{
+       0,   149,   150,   150,   150,   150,   150,   151,   153,   152,
+     155,   154,   156,   156,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     158,   157,   157,   157,   159,   159,   159,   160,   160,   161,
+     161,   162,   162,   162,   164,   163,   165,   165,   165,   167,
+     166,   168,   168,   169,   169,   169,   169,   169,   169,   169,
+     169,   169,   169,   169,   169,   169,   169,   169,   169,   169,
+     169,   169,   170,   169,   169,   171,   169,   169,   169,   169,
+     169,   169,   172,   172,   172,   172,   172,   172,   173,   172,
+     174,   172,   175,   172,   176,   177,   177,   177,   178,   178,
+     179,   178,   180,   180,   180,   181,   181,   181,   181,   181,
+     181,   181,   181,   181,   182,   182,   183,   183,   184,   184,
+     184,   185,   186,   185,   187,   187,   187,   187,   187,   187,
+     187,   187,   188,   187,   189,   187,   190,   190,   191,   191,
+     192,   192,   192,   192,   192,   193,   194,   194,   195,   195,
+     195,   195,   195,   195,   195,   195,   196,   196,   197,   197,
+     197,   197,   198,   198,   199,   200,   200,   201,   201,   203,
+     202,   204,   202,   205,   206,   207,   207,   208,   208,   209,
+     209,   210,   211,   211,   212,   212,   213,   214,   214,   215,
+     215,   216,   216,   216,   218,   217,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   220,   220,   221,   221,   222,
+     222,   223,   223,   224,   224,   224,   224,   226,   227,   228,
+     229,   230,   225,   231,   232,   233,   234,   235,   225,   236,
+     237,   225,   238,   225,   239,   239,   239,   239,   239,   240,
+     240,   240,   241,   241,   241,   241,   242,   242,   243,   243,
+     244,   244,   245,   245,   246,   247,   248,   249,   246,   250,
+     251,   251,   253,   254,   252,   255,   256,   256,   256,   257,
+     257,   259,   258,   260,   260,   261,   262,   264,   263,   266,
+     265,   267,   267,   268,   268,   268,   269,   269,   270,   270,
+     270,   270,   270,   271,   271,   271,   271,   272,   271,   273,
+     271,   271,   271,   271,   271,   271,   271,   274,   274
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     1,     0,     4,
+       0,     2,     3,     0,     2,     4,     1,     1,     2,     1,
+       4,     4,     3,     2,     4,     3,     4,     4,     4,     4,
+       4,     2,     2,     2,     4,     4,     2,     2,     2,     2,
+       0,     5,     2,     0,     3,     2,     0,     1,     3,     1,
+       3,     0,     1,     3,     0,     2,     1,     2,     3,     0,
+       2,     2,     0,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     4,     4,     4,     4,     8,     4,     1,
+       1,     4,     0,     5,     4,     0,     5,     4,     4,     3,
+       3,     6,     1,     3,     2,     1,     3,     2,     0,     5,
+       0,     7,     0,     6,     4,     2,     2,     0,     4,     2,
+       0,     7,     1,     1,     1,     1,     5,     4,     4,     7,
+       7,     7,     7,     8,     2,     1,     3,     1,     1,     3,
+       4,     1,     0,     5,     2,     1,     1,     1,     4,     1,
+       4,     4,     0,     8,     0,     5,     2,     1,     0,     1,
+       1,     1,     1,     1,     1,     1,     2,     0,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     3,
+       6,     6,     1,     0,     4,     1,     0,     3,     1,     0,
+       7,     0,     5,     3,     3,     0,     3,     1,     2,     1,
+       2,     4,     4,     3,     3,     1,     4,     3,     0,     1,
+       1,     0,     2,     3,     0,     2,     2,     3,     4,     2,
+       2,     2,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     5,     3,
+       3,     4,     1,     1,     4,     4,     4,     4,     4,     4,
+       4,     6,     6,     6,     4,     6,     4,     1,     6,     6,
+       4,     4,     6,     4,     4,     3,     0,     4,     0,     4,
+       0,     4,     0,     1,     1,     1,     0,     0,     0,     0,
+       0,     0,    19,     0,     0,     0,     0,     0,    18,     0,
+       0,     7,     0,     5,     1,     1,     1,     1,     1,     3,
+       0,     2,     3,     2,     6,    10,     2,     1,     0,     1,
+       2,     0,     0,     3,     0,     0,     0,     0,    11,     4,
+       0,     2,     0,     0,     6,     1,     0,     3,     5,     0,
+       3,     0,     2,     1,     2,     4,     2,     0,     2,     0,
+       5,     1,     2,     4,     5,     6,     1,     2,     0,     2,
+       4,     4,     8,     1,     1,     3,     3,     0,     9,     0,
+       7,     1,     3,     1,     3,     1,     3,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint16 yydefact[] =
+{
+       0,    59,    10,     8,   327,   321,     0,     2,    62,     3,
+      13,     6,     0,     4,     0,     5,     0,     1,    60,    11,
+       0,   338,     0,   328,   331,     0,   322,   323,     0,     0,
+       0,     0,     0,    79,     0,    80,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   199,   200,     0,     0,
+      82,     0,     0,     0,   110,     0,    72,    61,    64,    70,
+       0,    63,    66,    67,    68,    69,    65,    71,     0,    16,
+       0,     0,     0,     0,    17,     0,     0,     0,    19,    46,
+       0,     0,     0,     0,     0,     0,    51,    54,     0,     0,
+       0,   344,   355,   343,   351,   353,     0,     0,   338,   332,
+     351,   353,     0,     0,   324,   204,   165,   164,   163,   162,
+     161,   160,   159,   158,   204,   107,   310,     0,     0,     0,
+       0,     7,    85,   176,     0,     0,     0,     0,     0,     0,
+       0,   198,   201,     0,     0,     0,     0,     0,     0,    54,
+     167,   166,   109,     0,     0,    40,     0,   232,   247,     0,
+       0,     0,     0,     0,     0,     0,     0,   233,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    14,     0,    49,    31,
+      47,    32,    18,    33,    23,     0,    36,     0,    37,    52,
+      38,    39,     0,    42,    12,     9,     0,     0,     0,     0,
+     339,     0,     0,   326,   168,     0,   169,     0,     0,    89,
+      90,     0,     0,    62,   179,     0,     0,   173,   178,     0,
+       0,     0,     0,     0,     0,   193,   195,   173,   173,   201,
+       0,    92,    95,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    13,     0,     0,   210,   206,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   209,   211,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    25,     0,     0,    45,     0,
+       0,     0,    22,     0,     0,    56,    55,   349,     0,     0,
+     333,   346,   356,   345,   352,   354,     0,   325,   205,   267,
+     104,     0,   273,   279,   106,   105,   312,   309,   311,     0,
+      76,    78,   329,   185,   181,   174,   172,     0,     0,    73,
+      74,    84,   108,   191,   192,     0,   196,     0,   201,   202,
+      87,    98,    94,    97,     0,     0,    81,     0,    75,   204,
+     204,     0,    88,     0,    27,    28,    43,    29,    30,   207,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   230,   229,   227,   226,   225,   220,   219,   223,
+     224,   222,   221,   218,   217,   215,   216,   212,   213,   214,
+      15,    26,    24,    50,    48,    44,    20,    21,    35,    34,
+      53,    57,     0,     0,   340,   341,     0,   336,   334,     0,
+     290,   282,     0,   290,     0,     0,    86,     0,     0,   176,
+     177,     0,   194,   197,   203,     0,   102,    93,    96,     0,
+      83,     0,     0,     0,   330,    41,     0,   240,   246,     0,
+       0,   244,     0,   231,   208,   235,   234,   236,   237,     0,
+       0,   250,   251,   253,   254,   239,     0,   238,     0,    58,
+     357,   354,   347,   337,   335,     0,     0,   290,     0,   258,
+     107,   297,     0,   298,   280,   315,   316,     0,   189,     0,
+       0,   187,     0,     0,    91,     0,     0,   100,   170,   171,
+       0,     0,     0,     0,     0,     0,     0,     0,   228,   358,
+       0,     0,     0,   284,   285,   286,   287,   288,   291,     0,
+       0,     0,     0,   293,     0,   260,     0,   296,   299,   258,
+       0,   319,     0,   313,     0,   190,   186,   188,     0,   173,
+     182,    99,     0,     0,   111,   241,   242,   243,   245,   248,
+     249,   252,   350,     0,   357,   289,     0,   292,     0,     0,
+     262,   283,   262,   107,     0,   316,     0,     0,    77,   204,
+       0,   103,     0,   342,     0,   290,     0,     0,     0,   268,
+     274,     0,     0,   317,     0,   314,   183,     0,   180,   101,
+     348,     0,     0,   257,     0,     0,   266,     0,   281,   320,
+     316,   204,     0,   294,   259,     0,   263,   264,   265,     0,
+     275,   318,   184,     0,   261,   269,   304,   290,   148,     0,
+       0,   128,   114,   113,   150,   151,   152,   153,   154,     0,
+       0,     0,     0,   135,   137,   142,     0,     0,   136,     0,
+     115,     0,   131,   139,   147,   149,     0,     0,     0,   305,
+     276,   295,     0,     0,   144,   204,     0,   132,     0,   112,
+       0,   127,   173,     0,   146,   270,   204,   134,     0,   301,
+       0,     0,     0,     0,     0,     0,     0,     0,   148,     0,
+     155,     0,     0,   125,     0,     0,   129,     0,   173,   301,
+       0,   148,     0,   256,     0,     0,   138,     0,   117,     0,
+       0,   118,     0,   141,     0,   112,     0,     0,   124,   126,
+     130,   256,   140,     0,   300,     0,   302,     0,     0,     0,
+       0,     0,   145,     0,   133,   116,   302,   306,     0,   157,
+       0,     0,     0,     0,     0,     0,   157,   302,   255,   204,
+       0,   277,   120,   119,     0,   121,   122,     0,   271,   157,
+     156,   303,   173,   123,   143,   173,   307,   278,   272,   173,
+     308
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     6,   122,    11,    12,     9,    10,    19,    89,   244,
+     182,   181,   179,   190,   191,   192,   306,     7,     8,    18,
+      57,   134,   213,   234,   445,   553,   506,    58,   207,   324,
+     138,   650,   651,   694,   672,   652,   653,   692,   654,   666,
+     688,   655,   656,   657,   689,   751,   114,   142,    60,   697,
+      61,   216,   217,   218,   333,   439,   549,   598,   438,   500,
+     501,    62,    63,   227,    64,   228,    65,   230,   690,   205,
+     249,   726,   535,   570,   589,   619,   325,   430,   606,   628,
+     699,   765,   432,   607,   626,   679,   762,   433,   540,   490,
+     529,   488,   489,   493,   539,   703,   739,   629,   678,   747,
+     769,    66,   208,   328,   434,   577,   496,   543,   575,    15,
+      16,    26,    27,   102,    13,    14,    67,    68,    23,    24,
+     429,    96,    97,   522,   423,   520
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -658
+static const yytype_int16 yypact[] =
+{
+     278,  -658,  -658,  -658,  -658,  -658,   116,  -658,  -658,  -658,
+    -658,  -658,    39,  -658,   -21,  -658,    88,  -658,   818,  1636,
+     148,    67,    95,   -21,  -658,   106,    88,  -658,   889,   112,
+     126,    70,   156,  -658,   189,  -658,   225,   174,   203,   217,
+     218,   227,   231,   245,   253,   260,  -658,  -658,   281,   289,
+    -658,   290,   292,   294,  -658,   295,  -658,  -658,  -658,  -658,
+      43,  -658,  -658,  -658,  -658,  -658,  -658,  -658,   188,  -658,
+     324,   225,   329,   672,  -658,   330,   332,   336,  -658,  -658,
+     337,   341,   342,   672,   345,   350,   352,  -658,   354,   243,
+     672,  -658,   362,  -658,   353,   355,   315,   230,    67,  -658,
+    -658,  -658,   317,   241,  -658,  -658,  -658,  -658,  -658,  -658,
+    -658,  -658,  -658,  -658,  -658,  -658,  -658,   381,   388,   394,
+     395,  -658,  -658,    47,   396,   400,   225,   225,   403,   225,
+      20,  -658,   406,    21,   374,   225,   410,   411,   384,  -658,
+    -658,  -658,  -658,   366,    33,  -658,    41,  -658,  -658,   672,
+     672,   672,   390,   391,   392,   397,   399,  -658,   404,   405,
+     407,   409,   414,   417,   421,   423,   424,   436,   438,   440,
+     441,   451,   453,   454,   672,   672,  1433,   228,  -658,   301,
+    -658,   305,     5,  -658,  -658,   387,   827,   306,  -658,  -658,
+     347,  -658,   427,  -658,  -658,   827,   376,   106,   106,   351,
+     114,   380,   356,   114,  -658,   672,  -658,   291,    34,  -658,
+    -658,   105,   309,  -658,  -658,   225,   443,    -2,  -658,   363,
+     349,   360,   371,   372,   373,  -658,  -658,   127,   145,    19,
+     377,  -658,  -658,   460,    16,    21,   378,   492,   500,   672,
+     379,   -21,   672,   672,  -658,   672,   672,  -658,  -658,   776,
+     672,   672,   672,   672,   672,   429,   503,   672,   514,   520,
+     521,   522,   672,   672,   672,   672,   524,   526,   672,   672,
+     529,  -658,  -658,   672,   672,   672,   672,   672,   672,   672,
+     672,   672,   672,   672,   672,   672,   672,   672,   672,   672,
+     672,   672,   672,   672,   672,   827,   534,   536,  -658,   537,
+     672,   672,   827,    66,   538,  -658,    25,  -658,   413,   418,
+    -658,  -658,   543,  -658,  -658,  -658,   -55,  -658,   827,   889,
+    -658,   225,  -658,  -658,  -658,  -658,  -658,  -658,  -658,   545,
+    -658,  -658,   882,   513,  -658,  -658,  -658,    47,   548,  -658,
+    -658,  -658,  -658,  -658,  -658,   225,  -658,   225,   406,  -658,
+    -658,  -658,  -658,  -658,   516,    28,  -658,    32,  -658,  -658,
+    -658,  1453,  -658,     7,   827,   827,  1660,   827,   827,  -658,
+    1009,  1029,  1473,  1493,  1049,   412,   419,  1069,   422,   426,
+     428,   430,  1521,  1559,  1089,  1109,   431,   432,  1137,  1579,
+     433,  1774,  1811,  1539,  1826,   663,   988,   688,   688,   601,
+     601,   601,   601,   452,   452,   270,   270,  -658,  -658,  -658,
+     827,   827,   827,  -658,  -658,  -658,   827,   827,  -658,  -658,
+    -658,  -658,   556,   106,   220,   114,   509,  -658,  -658,    14,
+     506,  -658,   589,   506,   672,   420,  -658,     3,   551,    47,
+    -658,   435,  -658,  -658,  -658,    21,  -658,  -658,  -658,   531,
+    -658,   437,   450,   576,  -658,  -658,   672,  -658,  -658,   672,
+     672,  -658,   672,  -658,  -658,  -658,  -658,  -658,  -658,   672,
+     672,  -658,  -658,  -658,  -658,  -658,   578,  -658,   672,  -658,
+     456,   579,  -658,  -658,  -658,    15,   559,  1628,   581,   501,
+    -658,  -658,  1794,   510,  -658,   827,    27,   599,  -658,   612,
+       2,  -658,   512,   586,  -658,   118,    21,  -658,  -658,  -658,
+     473,  1157,  1177,  1197,  1217,  1237,  1265,   479,   827,   114,
+     567,   106,   106,  -658,  -658,  -658,  -658,  -658,  -658,   481,
+     672,   311,   620,  -658,   602,   605,   416,  -658,  -658,   501,
+     582,   607,   608,  -658,   504,  -658,  -658,  -658,   643,   508,
+    -658,  -658,   130,    21,  -658,  -658,  -658,  -658,  -658,  -658,
+    -658,  -658,  -658,   515,   456,  -658,  1285,  -658,   672,   614,
+     553,  -658,   553,  -658,   672,    27,   672,   517,  -658,  -658,
+     562,  -658,   134,   114,   606,   257,  1305,   672,   622,  -658,
+    -658,   359,  1325,  -658,  1345,  -658,  -658,   651,  -658,  -658,
+    -658,   625,   648,  -658,  1365,   672,   -88,   609,  -658,  -658,
+      27,  -658,   672,  -658,  -658,  1393,  -658,  -658,  -658,   621,
+    -658,  -658,  -658,  1413,  -658,  -658,  -658,   641,   728,    58,
+     664,   600,  -658,  -658,  -658,  -658,  -658,  -658,  -658,   642,
+     645,   225,   662,  -658,  -658,  -658,   668,   669,  -658,   238,
+    -658,   670,  -658,  -658,  -658,   728,   644,   671,    43,  -658,
+    -658,  -658,   310,   284,  -658,  -658,   689,  -658,    57,  -658,
+     690,  -658,   -29,   238,  -658,  -658,  -658,  -658,   675,   703,
+     696,   697,   594,   702,   596,   704,   705,   603,   728,   604,
+    -658,   672,    26,  -658,    12,   269,  -658,   238,   173,   703,
+     615,   728,   741,   657,    57,    57,  -658,    57,  -658,    57,
+      57,  -658,   710,  -658,  1599,   617,   618,    57,  -658,  -658,
+    -658,   657,  -658,   706,  -658,   740,  -658,   623,   624,    99,
+     630,   631,  -658,   772,  -658,  -658,  -658,  -658,   773,   136,
+     634,   635,    57,   636,   640,   646,   136,  -658,  -658,  -658,
+     781,  -658,  -658,  -658,   667,  -658,  -658,    43,  -658,   136,
+    -658,  -658,   508,  -658,  -658,   508,  -658,  -658,  -658,   508,
+    -658
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -658,  -658,   -70,  -658,  -658,  -658,  -658,   542,  -658,  -658,
+    -658,  -658,  -658,  -658,   561,  -658,  -658,  -658,  -658,   575,
+    -658,  -658,  -658,  -223,  -658,  -658,  -658,  -658,  -448,   -13,
+    -658,   974,  -544,    82,   140,   122,  -658,  -658,   160,  -658,
+    -658,  -658,  -440,  -658,    68,  -496,  -658,  -630,  -403,  -214,
+    -658,   385,  -658,   488,  -658,  -658,  -658,  -658,  -658,  -658,
+     316,  -658,  -658,  -658,  -658,  -658,  -658,  -207,  -103,  -658,
+     -73,    97,   287,  -658,   256,  -658,  -658,  -658,  -658,  -658,
+    -658,  -658,  -658,  -658,  -658,  -658,  -658,  -658,  -658,  -658,
+    -658,  -479,   401,  -658,  -658,   131,  -657,  -658,  -658,  -658,
+    -658,  -658,  -658,  -658,  -658,  -658,  -658,  -535,  -658,  -658,
+    -658,  -658,   803,  -658,  -658,  -658,  -658,  -658,   592,   -19,
+    -658,   737,   -10,  -658,  -658,   272
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -330
+static const yytype_int16 yytable[] =
+{
+     176,   145,   204,   337,    99,    59,   498,   498,   532,   298,
+     186,   206,   357,   345,   347,   103,   669,   195,   147,   148,
+     352,   353,   349,   229,   121,   231,   232,   632,   677,   421,
+     715,   541,   447,   448,  -175,    21,   352,   353,   326,   242,
+     593,   632,   536,    20,   633,   149,   150,   245,   616,   617,
+     618,   214,   151,   152,   153,  -175,   221,   222,   633,   224,
+     226,   669,   659,    21,   454,   236,   154,   155,   156,   418,
+     419,    91,   632,   157,   427,   621,   247,   248,   158,   746,
+     670,   640,   523,   524,   525,   526,   527,   159,   428,   633,
+     759,   327,   160,   161,   162,   163,   164,   165,   166,   167,
+     168,   271,   272,   669,   295,   671,   602,   169,    22,   170,
+      91,   215,   302,   336,   632,   660,    17,   696,   311,   117,
+     118,   354,   352,   353,   171,   591,   233,   764,   542,   671,
+     172,   633,   318,   449,   352,   353,    22,   354,   352,   353,
+     336,   444,   749,   483,    25,   334,   546,   299,   630,   499,
+     499,    98,   750,   719,    90,   173,   717,   484,   355,   528,
+     356,   348,   174,   175,   225,   647,   361,   422,   115,   364,
+     365,   649,   367,   368,   355,   243,   450,   370,   371,   372,
+     373,   374,   116,   246,   377,   140,   141,   308,   309,   382,
+     383,   384,   385,   119,    92,   388,   389,    93,    94,    95,
+     391,   392,   393,   394,   395,   396,   397,   398,   399,   400,
+     401,   402,   403,   404,   405,   406,   407,   408,   409,   410,
+     411,   412,   505,   354,   311,   658,   120,   416,   417,   121,
+     123,   147,   148,    92,   293,   354,    93,   100,   101,   354,
+     124,   312,   669,   742,   313,   314,   315,   329,   712,   330,
+     758,   431,   658,   632,   125,   126,   451,   452,   149,   150,
+     355,   723,   551,   766,   127,   151,   152,   153,   128,   336,
+     633,   344,   355,   669,   581,   442,   355,   443,   599,   154,
+     155,   156,   129,   552,   632,   658,   157,   336,   669,   346,
+     130,   158,   670,   640,   531,   319,   601,   131,   658,   632,
+     159,   633,   289,   290,   291,   160,   161,   162,   163,   164,
+     165,   166,   167,   168,   669,   336,   633,   720,   132,    59,
+     169,   143,   170,   680,   681,   632,   133,   135,   144,   136,
+     582,   137,   139,   146,   177,   580,   178,   171,   685,   686,
+     180,   183,   633,   172,    99,   184,   185,   312,   320,   187,
+     313,   314,   481,   188,   194,   321,   189,   487,   193,   492,
+     487,   495,   322,   319,   680,   681,   196,    42,   173,   197,
+     294,   198,   199,   200,   202,   174,   175,   647,   523,   524,
+     525,   526,   527,   511,   203,   209,   512,   513,   323,   514,
+     147,   148,   210,   300,    52,    53,   515,   516,   211,   212,
+     219,     1,     2,     3,   220,   518,    54,   223,   683,   682,
+     229,   235,     4,   480,   237,   238,   608,   149,   150,     5,
+     319,   239,   241,   321,   151,   152,   153,   250,   251,   252,
+     322,   305,   307,   375,   253,    42,   254,   316,   154,   155,
+     156,   255,   256,   296,   257,   157,   258,   297,   303,   683,
+     158,   259,   571,   331,   260,   528,   323,   566,   261,   159,
+     262,   263,    52,    53,   160,   161,   162,   163,   164,   165,
+     166,   167,   168,   264,    54,   265,   596,   266,   267,   169,
+     321,   170,   287,   288,   289,   290,   291,   322,   268,   304,
+     269,   270,    42,   339,   310,   586,   171,   351,   359,   317,
+     335,   592,   172,   594,   340,   338,   360,   376,   622,   147,
+     148,   563,   564,   323,   604,   341,   342,   343,   378,    52,
+      53,   350,   358,   362,   379,   380,   381,   173,   386,   301,
+     387,    54,   615,   390,   174,   175,   149,   150,   413,   623,
+     414,   415,   420,   485,   152,   153,   486,   426,   767,   435,
+     437,   768,   441,   446,   462,   770,   424,   154,   155,   156,
+     479,   425,   497,   463,   157,   482,   465,   502,   507,   158,
+     466,   664,   467,   700,   468,   473,   474,   477,   159,   504,
+     510,   508,   517,   160,   161,   162,   163,   164,   165,   166,
+     167,   168,   147,   148,   509,   521,   530,   533,   169,   519,
+     170,   538,   534,   544,   548,   491,   105,   106,   107,   108,
+     109,   110,   111,   112,   113,   171,   545,   554,   714,   149,
+     150,   172,   550,   561,   562,   565,   151,   152,   153,   285,
+     286,   287,   288,   289,   290,   291,   567,  -112,   573,   568,
+     154,   155,   156,   569,   574,   576,   173,   157,   578,   579,
+     336,   587,   158,   174,   175,   588,   597,   611,   583,   605,
+     595,   159,   612,   600,   613,   620,   160,   161,   162,   163,
+     164,   165,   166,   167,   168,   147,   148,   625,   531,   662,
+     661,   169,   663,   170,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   171,   665,
+     240,   675,   149,   150,   172,   667,   668,   673,   676,   151,
+     152,   153,   281,   282,   283,   284,   285,   286,   287,   288,
+     289,   290,   291,   154,   155,   156,   691,   695,   702,   173,
+     157,   701,   631,   704,   705,   158,   174,   175,   706,   707,
+     708,   709,   710,   632,   159,   724,   732,   711,   713,   160,
+     161,   162,   163,   164,   165,   166,   167,   168,   725,   722,
+     633,  -128,   734,   737,   169,   738,   170,   740,   741,   634,
+     635,   636,   637,   638,   743,   744,   745,   748,   752,   753,
+     755,   171,   639,   640,   756,   761,   366,   172,   332,   729,
+     757,   273,   641,   274,   275,   276,   277,   278,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291,   763,   173,   698,   716,   674,   547,   760,   736,   174,
+     175,   642,    28,   643,   503,   440,   572,   644,   590,   104,
+     721,    52,    53,   363,   494,   201,   584,     0,     0,     0,
+       0,     0,   273,   645,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,     0,   646,    29,    30,    31,   647,     0,     0,
+       0,   648,     0,   649,     0,     0,     0,    32,    33,    34,
+      35,     0,    36,    37,    38,     0,    28,     0,     0,     0,
+       0,    39,    40,    41,    42,   105,   106,   107,   108,   109,
+     110,   111,   112,   113,    43,    44,    45,    46,    47,    48,
+       0,     0,     0,     0,    49,    50,    51,     0,   436,     0,
+     369,    52,    53,     0,     0,     0,     0,     0,    29,    30,
+      31,     0,     0,    54,     0,     0,     0,     0,     0,     0,
+       0,    32,    33,    34,    35,    55,    36,    37,    38,     0,
+       0,  -329,     0,     0,     0,    39,    40,    41,    42,     0,
+       0,    56,     0,     0,     0,     0,     0,     0,    43,    44,
+      45,    46,    47,    48,     0,     0,     0,     0,    49,    50,
+      51,     0,     0,     0,     0,    52,    53,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    54,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    55,
+     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
+     289,   290,   291,     0,   273,    56,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,     0,     0,     0,     0,     0,     0,
+       0,   456,   273,   457,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   458,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   461,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   464,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   471,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   472,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,     0,     0,     0,     0,     0,     0,     0,     0,
+     273,   475,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   555,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   556,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   557,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   558,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   559,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+       0,     0,     0,     0,     0,     0,     0,     0,   273,   560,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   585,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   603,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   609,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   610,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   614,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,     0,     0,
+       0,     0,     0,     0,     0,     0,   273,   624,   274,   275,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+     286,   287,   288,   289,   290,   291,     0,   627,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,   292,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,   453,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,   459,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,     0,   460,   684,   687,     0,     0,
+      69,     0,   693,   273,     0,   274,   275,   276,   277,   278,
+     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
+     289,   290,   291,   469,    69,   531,     0,     0,   718,   684,
+       0,     0,     0,     0,    70,     0,     0,     0,   727,   728,
+       0,   693,     0,   730,   731,     0,     0,     0,     0,     0,
+       0,   735,     0,     0,     0,     0,   455,     0,    70,     0,
+      71,   470,     0,   718,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   754,     0,     0,     0,
+       0,   476,     0,     0,    71,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    72,     0,     0,     0,
+       0,   733,    73,    74,    75,    76,    77,   -43,    78,    79,
+      80,     0,    81,    82,     0,    83,    84,    85,     0,     0,
+      72,     0,    86,    87,    88,     0,    73,    74,    75,    76,
+      77,     0,    78,    79,    80,     0,    81,    82,     0,    83,
+      84,    85,     0,     0,     0,     0,    86,    87,    88,   273,
+     478,   274,   275,   276,   277,   278,   279,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   273,
+     537,   274,   275,   276,   277,   278,   279,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   275,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+     286,   287,   288,   289,   290,   291,   277,   278,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291
+};
+
+static const yytype_int16 yycheck[] =
+{
+      73,    71,   105,   217,    23,    18,     4,     4,   487,     4,
+      83,   114,   235,   227,   228,    25,     4,    90,     3,     4,
+       4,     5,   229,     4,     4,     4,     5,    15,   658,     4,
+       4,     4,     4,     5,    36,    56,     4,     5,     4,     6,
+     575,    15,   490,     4,    32,    30,    31,     6,   136,   137,
+     138,     4,    37,    38,    39,    57,   126,   127,    32,   129,
+     130,     4,     4,    56,    57,   135,    51,    52,    53,     3,
+       4,     4,    15,    58,   129,   610,   149,   150,    63,   736,
+      54,    55,    67,    68,    69,    70,    71,    72,   143,    32,
+     747,    57,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,   174,   175,     4,   177,   649,   585,    92,   129,    94,
+       4,    64,   185,   142,    15,    57,     0,   146,     4,    49,
+      50,   105,     4,     5,   109,   573,   105,   757,   101,   673,
+     115,    32,   205,   105,     4,     5,   129,   105,     4,     5,
+     142,   348,     6,   129,    56,   215,   144,   142,   627,   147,
+     147,    56,    16,   697,     6,   140,   144,   143,   142,   144,
+     144,   142,   147,   148,   144,   139,   239,   142,    56,   242,
+     243,   145,   245,   246,   142,   142,   144,   250,   251,   252,
+     253,   254,    56,   142,   257,   142,   143,   197,   198,   262,
+     263,   264,   265,    37,   127,   268,   269,   130,   131,   132,
+     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   292,
+     293,   294,   445,   105,     4,   628,    37,   300,   301,     4,
+      56,     3,     4,   127,     6,   105,   130,   131,   132,   105,
+      37,   127,     4,   144,   130,   131,   132,   142,   688,   144,
+     746,   321,   655,    15,    37,    37,   359,   360,    30,    31,
+     142,   701,   144,   759,    37,    37,    38,    39,    37,   142,
+      32,   144,   142,     4,   144,   345,   142,   347,   144,    51,
+      52,    53,    37,   506,    15,   688,    58,   142,     4,   144,
+      37,    63,    54,    55,    37,     4,    39,    37,   701,    15,
+      72,    32,    32,    33,    34,    77,    78,    79,    80,    81,
+      82,    83,    84,    85,     4,   142,    32,   144,    37,   332,
+      92,   133,    94,    54,    55,    15,    37,    37,     4,    37,
+     553,    37,    37,     4,     4,   549,     4,   109,    54,    55,
+       4,     4,    32,   115,   363,     4,     4,   127,    57,     4,
+     130,   131,   132,     3,   111,    64,     4,   430,     4,   432,
+     433,   434,    71,     4,    54,    55,     4,    76,   140,    16,
+     142,    16,    57,   143,    57,   147,   148,   139,    67,    68,
+      69,    70,    71,   456,   143,     4,   459,   460,    97,   462,
+       3,     4,     4,     6,   103,   104,   469,   470,     4,     4,
+       4,   123,   124,   125,     4,   478,   115,     4,   139,    99,
+       4,    37,   134,   423,     4,     4,    57,    30,    31,   141,
+       4,    37,    56,    64,    37,    38,    39,    37,    37,    37,
+      71,     4,    56,     4,    37,    76,    37,    57,    51,    52,
+      53,    37,    37,   142,    37,    58,    37,   142,   142,   139,
+      63,    37,    36,   144,    37,   144,    97,   530,    37,    72,
+      37,    37,   103,   104,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    37,   115,    37,   579,    37,    37,    92,
+      64,    94,    30,    31,    32,    33,    34,    71,    37,   142,
+      37,    37,    76,   144,   143,   568,   109,    37,     6,   143,
+      57,   574,   115,   576,   144,   142,     6,     4,   611,     3,
+       4,   521,   522,    97,   587,   144,   144,   144,     4,   103,
+     104,   144,   144,   144,     4,     4,     4,   140,     4,   142,
+       4,   115,   605,     4,   147,   148,    30,    31,     4,   612,
+       4,     4,     4,    37,    38,    39,    40,     4,   762,     4,
+      37,   765,     4,    37,   142,   769,   143,    51,    52,    53,
+       4,   143,   142,   144,    58,    56,   144,    16,    37,    63,
+     144,   641,   144,   676,   144,   144,   144,   144,    72,   144,
+       4,   144,     4,    77,    78,    79,    80,    81,    82,    83,
+      84,    85,     3,     4,   144,    16,    37,    16,    92,   143,
+      94,    91,   101,     4,    92,    16,     6,     7,     8,     9,
+      10,    11,    12,    13,    14,   109,     4,   144,   691,    30,
+      31,   115,    36,   144,    57,   144,    37,    38,    39,    28,
+      29,    30,    31,    32,    33,    34,    16,    37,    56,    37,
+      51,    52,    53,    38,    37,    37,   140,    58,   144,     6,
+     142,    37,    63,   147,   148,   102,    94,     6,   143,    37,
+     143,    72,    37,    57,    16,    56,    77,    78,    79,    80,
+      81,    82,    83,    84,    85,     3,     4,    56,    37,    37,
+      16,    92,    37,    94,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,   109,    37,
+     139,    57,    30,    31,   115,    37,    37,    37,    37,    37,
+      38,    39,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    51,    52,    53,    37,    37,    25,   140,
+      58,    56,     4,    37,    37,    63,   147,   148,   144,    37,
+     144,    37,    37,    15,    72,     4,    36,   144,   144,    77,
+      78,    79,    80,    81,    82,    83,    84,    85,   101,   144,
+      32,   144,   144,    57,    92,    25,    94,   144,   144,    41,
+      42,    43,    44,    45,   144,   144,     4,     4,   144,   144,
+     144,   109,    54,    55,   144,     4,   244,   115,   213,   707,
+     144,    15,    64,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,   144,   140,   673,   692,   655,   500,   749,   721,   147,
+     148,    93,     4,    95,   439,   337,   539,    99,   572,    26,
+     699,   103,   104,   241,   433,    98,   564,    -1,    -1,    -1,
+      -1,    -1,    15,   115,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    -1,   135,    46,    47,    48,   139,    -1,    -1,
+      -1,   143,    -1,   145,    -1,    -1,    -1,    59,    60,    61,
+      62,    -1,    64,    65,    66,    -1,     4,    -1,    -1,    -1,
+      -1,    73,    74,    75,    76,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    86,    87,    88,    89,    90,    91,
+      -1,    -1,    -1,    -1,    96,    97,    98,    -1,    36,    -1,
+     144,   103,   104,    -1,    -1,    -1,    -1,    -1,    46,    47,
+      48,    -1,    -1,   115,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    59,    60,    61,    62,   127,    64,    65,    66,    -1,
+      -1,   133,    -1,    -1,    -1,    73,    74,    75,    76,    -1,
+      -1,   143,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    -1,    96,    97,
+      98,    -1,    -1,    -1,    -1,   103,   104,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   127,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    -1,    15,   143,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,   142,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    15,   144,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    -1,   144,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,   142,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,   142,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,   142,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    -1,   142,   662,   663,    -1,    -1,
+       4,    -1,   668,    15,    -1,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,   142,     4,    37,    -1,    -1,   694,   695,
+      -1,    -1,    -1,    -1,    38,    -1,    -1,    -1,   704,   705,
+      -1,   707,    -1,   709,   710,    -1,    -1,    -1,    -1,    -1,
+      -1,   717,    -1,    -1,    -1,    -1,    36,    -1,    38,    -1,
+      64,   142,    -1,   729,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   742,    -1,    -1,    -1,
+      -1,   142,    -1,    -1,    64,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   100,    -1,    -1,    -1,
+      -1,   142,   106,   107,   108,   109,   110,   111,   112,   113,
+     114,    -1,   116,   117,    -1,   119,   120,   121,    -1,    -1,
+     100,    -1,   126,   127,   128,    -1,   106,   107,   108,   109,
+     110,    -1,   112,   113,   114,    -1,   116,   117,    -1,   119,
+     120,   121,    -1,    -1,    -1,    -1,   126,   127,   128,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint16 yystos[] =
+{
+       0,   123,   124,   125,   134,   141,   150,   166,   167,   154,
+     155,   152,   153,   263,   264,   258,   259,     0,   168,   156,
+       4,    56,   129,   267,   268,    56,   260,   261,     4,    46,
+      47,    48,    59,    60,    61,    62,    64,    65,    66,    73,
+      74,    75,    76,    86,    87,    88,    89,    90,    91,    96,
+      97,    98,   103,   104,   115,   127,   143,   169,   176,   178,
+     197,   199,   210,   211,   213,   215,   250,   265,   266,     4,
+      38,    64,   100,   106,   107,   108,   109,   110,   112,   113,
+     114,   116,   117,   119,   120,   121,   126,   127,   128,   157,
+       6,     4,   127,   130,   131,   132,   270,   271,    56,   268,
+     131,   132,   262,   271,   261,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,   195,    56,    56,    49,    50,    37,
+      37,     4,   151,    56,    37,    37,    37,    37,    37,    37,
+      37,    37,    37,    37,   170,    37,    37,    37,   179,    37,
+     142,   143,   196,   133,     4,   151,     4,     3,     4,    30,
+      31,    37,    38,    39,    51,    52,    53,    58,    63,    72,
+      77,    78,    79,    80,    81,    82,    83,    84,    85,    92,
+      94,   109,   115,   140,   147,   148,   219,     4,     4,   161,
+       4,   160,   159,     4,     4,     4,   219,     4,     3,     4,
+     162,   163,   164,     4,   111,   219,     4,    16,    16,    57,
+     143,   270,    57,   143,   217,   218,   217,   177,   251,     4,
+       4,     4,     4,   171,     4,    64,   200,   201,   202,     4,
+       4,   151,   151,     4,   151,   144,   151,   212,   214,     4,
+     216,     4,     5,   105,   172,    37,   151,     4,     4,    37,
+     163,    56,     6,   142,   158,     6,   142,   219,   219,   219,
+      37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
+      37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
+      37,   219,   219,    15,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,   142,     6,   142,   219,   142,   142,     4,   142,
+       6,   142,   219,   142,   142,     4,   165,    56,   271,   271,
+     143,     4,   127,   130,   131,   132,    57,   143,   219,     4,
+      57,    64,    71,    97,   178,   225,     4,    57,   252,   142,
+     144,   144,   168,   203,   151,    57,   142,   198,   142,   144,
+     144,   144,   144,   144,   144,   198,   144,   198,   142,   216,
+     144,    37,     4,     5,   105,   142,   144,   172,   144,     6,
+       6,   219,   144,   267,   219,   219,   156,   219,   219,   144,
+     219,   219,   219,   219,   219,     4,     4,   219,     4,     4,
+       4,     4,   219,   219,   219,   219,     4,     4,   219,   219,
+       4,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,     4,     4,     4,   219,   219,     3,     4,
+       4,     4,   142,   273,   143,   143,     4,   129,   143,   269,
+     226,   151,   231,   236,   253,     4,    36,    37,   207,   204,
+     202,     4,   151,   151,   216,   173,    37,     4,     5,   105,
+     144,   217,   217,   142,    57,    36,   142,   144,   144,   142,
+     142,   144,   142,   144,   144,   144,   144,   144,   144,   142,
+     142,   144,   144,   144,   144,   144,   142,   144,    16,     4,
+     271,   132,    56,   129,   143,    37,    40,   219,   240,   241,
+     238,    16,   219,   242,   241,   219,   255,   142,     4,   147,
+     208,   209,    16,   200,   144,   172,   175,    37,   144,   144,
+       4,   219,   219,   219,   219,   219,   219,     4,   219,   143,
+     274,    16,   272,    67,    68,    69,    70,    71,   144,   239,
+      37,    37,   240,    16,   101,   221,   177,    16,    91,   243,
+     237,     4,   101,   256,     4,     4,   144,   209,    92,   205,
+      36,   144,   172,   174,   144,   144,   144,   144,   144,   144,
+     144,   144,    57,   271,   271,   144,   219,    16,    37,    38,
+     222,    36,   221,    56,    37,   257,    37,   254,   144,     6,
+     198,   144,   172,   143,   274,   144,   219,    37,   102,   223,
+     223,   177,   219,   256,   219,   143,   217,    94,   206,   144,
+      57,    39,   240,   144,   219,    37,   227,   232,    57,   144,
+     144,     6,    37,    16,   144,   219,   136,   137,   138,   224,
+      56,   256,   217,   219,   144,    56,   233,   144,   228,   246,
+     240,     4,    15,    32,    41,    42,    43,    44,    45,    54,
+      55,    64,    93,    95,    99,   115,   135,   139,   143,   145,
+     180,   181,   184,   185,   187,   190,   191,   192,   197,     4,
+      57,    16,    37,    37,   151,    37,   188,    37,    37,     4,
+      54,   181,   183,    37,   187,    57,    37,   196,   247,   234,
+      54,    55,    99,   139,   180,    54,    55,   180,   189,   193,
+     217,    37,   186,   180,   182,    37,   146,   198,   183,   229,
+     217,    56,    25,   244,    37,    37,   144,    37,   144,    37,
+      37,   144,   191,   144,   219,     4,   184,   144,   180,   181,
+     144,   244,   144,   191,     4,   101,   220,   180,   180,   182,
+     180,   180,    36,   142,   144,   180,   220,    57,    25,   245,
+     144,   144,   144,   144,   144,     4,   245,   248,     4,     6,
+      16,   194,   144,   144,   180,   144,   144,   144,   194,   245,
+     193,     4,   235,   144,   196,   230,   194,   198,   198,   249,
+     198
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 8:
+
+/* Line 1455 of yacc.c  */
+#line 173 "ldgram.y"
+    { ldlex_defsym(); }
+    break;
+
+  case 9:
+
+/* Line 1455 of yacc.c  */
+#line 175 "ldgram.y"
+    {
+		  ldlex_popstate();
+		  lang_add_assignment(exp_assop((yyvsp[(3) - (4)].token),(yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)));
+		}
+    break;
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 183 "ldgram.y"
+    {
+		  ldlex_mri_script ();
+		  PUSH_ERROR (_("MRI style script"));
+		}
+    break;
+
+  case 11:
+
+/* Line 1455 of yacc.c  */
+#line 188 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  mri_draw_tree ();
+		  POP_ERROR ();
+		}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 203 "ldgram.y"
+    {
+			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),(yyvsp[(1) - (1)].name));
+			}
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 206 "ldgram.y"
+    {
+			config.map_filename = "-";
+			}
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 212 "ldgram.y"
+    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 214 "ldgram.y"
+    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 216 "ldgram.y"
+    { mri_public((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 218 "ldgram.y"
+    { mri_format((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 220 "ldgram.y"
+    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 222 "ldgram.y"
+    { mri_output_section((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree));}
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 224 "ldgram.y"
+    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 226 "ldgram.y"
+    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 228 "ldgram.y"
+    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 230 "ldgram.y"
+    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 232 "ldgram.y"
+    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 236 "ldgram.y"
+    { mri_name((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 238 "ldgram.y"
+    { mri_alias((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].name),0);}
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 240 "ldgram.y"
+    { mri_alias ((yyvsp[(2) - (4)].name), 0, (int) (yyvsp[(4) - (4)].bigint).integer); }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 242 "ldgram.y"
+    { mri_base((yyvsp[(2) - (2)].etree)); }
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 244 "ldgram.y"
+    { mri_truncate ((unsigned int) (yyvsp[(2) - (2)].bigint).integer); }
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 248 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 250 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 252 "ldgram.y"
+    { lang_add_entry ((yyvsp[(2) - (2)].name), FALSE); }
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 257 "ldgram.y"
+    { mri_order((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 258 "ldgram.y"
+    { mri_order((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 47:
+
+/* Line 1455 of yacc.c  */
+#line 264 "ldgram.y"
+    { mri_load((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 265 "ldgram.y"
+    { mri_load((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 270 "ldgram.y"
+    { mri_only_load((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 272 "ldgram.y"
+    { mri_only_load((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 276 "ldgram.y"
+    { (yyval.name) = NULL; }
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 283 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 285 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 289 "ldgram.y"
+    { ldlang_add_undef ((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 291 "ldgram.y"
+    { ldlang_add_undef ((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 293 "ldgram.y"
+    { ldlang_add_undef ((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 297 "ldgram.y"
+    { ldlex_both(); }
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 299 "ldgram.y"
+    { ldlex_popstate(); }
+    break;
+
+  case 73:
+
+/* Line 1455 of yacc.c  */
+#line 320 "ldgram.y"
+    { lang_add_target((yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 74:
+
+/* Line 1455 of yacc.c  */
+#line 322 "ldgram.y"
+    { ldfile_add_library_path ((yyvsp[(3) - (4)].name), FALSE); }
+    break;
+
+  case 75:
+
+/* Line 1455 of yacc.c  */
+#line 324 "ldgram.y"
+    { lang_add_output((yyvsp[(3) - (4)].name), 1); }
+    break;
+
+  case 76:
+
+/* Line 1455 of yacc.c  */
+#line 326 "ldgram.y"
+    { lang_add_output_format ((yyvsp[(3) - (4)].name), (char *) NULL,
+					    (char *) NULL, 1); }
+    break;
+
+  case 77:
+
+/* Line 1455 of yacc.c  */
+#line 329 "ldgram.y"
+    { lang_add_output_format ((yyvsp[(3) - (8)].name), (yyvsp[(5) - (8)].name), (yyvsp[(7) - (8)].name), 1); }
+    break;
+
+  case 78:
+
+/* Line 1455 of yacc.c  */
+#line 331 "ldgram.y"
+    { ldfile_set_output_arch ((yyvsp[(3) - (4)].name), bfd_arch_unknown); }
+    break;
+
+  case 79:
+
+/* Line 1455 of yacc.c  */
+#line 333 "ldgram.y"
+    { command_line.force_common_definition = TRUE ; }
+    break;
+
+  case 80:
+
+/* Line 1455 of yacc.c  */
+#line 335 "ldgram.y"
+    { command_line.inhibit_common_definition = TRUE ; }
+    break;
+
+  case 82:
+
+/* Line 1455 of yacc.c  */
+#line 338 "ldgram.y"
+    { lang_enter_group (); }
+    break;
+
+  case 83:
+
+/* Line 1455 of yacc.c  */
+#line 340 "ldgram.y"
+    { lang_leave_group (); }
+    break;
+
+  case 84:
+
+/* Line 1455 of yacc.c  */
+#line 342 "ldgram.y"
+    { lang_add_map((yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 85:
+
+/* Line 1455 of yacc.c  */
+#line 344 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 86:
+
+/* Line 1455 of yacc.c  */
+#line 346 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 87:
+
+/* Line 1455 of yacc.c  */
+#line 348 "ldgram.y"
+    {
+		  lang_add_nocrossref ((yyvsp[(3) - (4)].nocrossref));
+		}
+    break;
+
+  case 89:
+
+/* Line 1455 of yacc.c  */
+#line 353 "ldgram.y"
+    { lang_add_insert ((yyvsp[(3) - (3)].name), 0); }
+    break;
+
+  case 90:
+
+/* Line 1455 of yacc.c  */
+#line 355 "ldgram.y"
+    { lang_add_insert ((yyvsp[(3) - (3)].name), 1); }
+    break;
+
+  case 91:
+
+/* Line 1455 of yacc.c  */
+#line 357 "ldgram.y"
+    { lang_memory_region_alias ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].name)); }
+    break;
+
+  case 92:
+
+/* Line 1455 of yacc.c  */
+#line 362 "ldgram.y"
+    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_search_file_enum,
+				 (char *)NULL); }
+    break;
+
+  case 93:
+
+/* Line 1455 of yacc.c  */
+#line 365 "ldgram.y"
+    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_search_file_enum,
+				 (char *)NULL); }
+    break;
+
+  case 94:
+
+/* Line 1455 of yacc.c  */
+#line 368 "ldgram.y"
+    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_search_file_enum,
+				 (char *)NULL); }
+    break;
+
+  case 95:
+
+/* Line 1455 of yacc.c  */
+#line 371 "ldgram.y"
+    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_l_enum,
+				 (char *)NULL); }
+    break;
+
+  case 96:
+
+/* Line 1455 of yacc.c  */
+#line 374 "ldgram.y"
+    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_l_enum,
+				 (char *)NULL); }
+    break;
+
+  case 97:
+
+/* Line 1455 of yacc.c  */
+#line 377 "ldgram.y"
+    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_l_enum,
+				 (char *)NULL); }
+    break;
+
+  case 98:
+
+/* Line 1455 of yacc.c  */
+#line 380 "ldgram.y"
+    { (yyval.integer) = as_needed; as_needed = TRUE; }
+    break;
+
+  case 99:
+
+/* Line 1455 of yacc.c  */
+#line 382 "ldgram.y"
+    { as_needed = (yyvsp[(3) - (5)].integer); }
+    break;
+
+  case 100:
+
+/* Line 1455 of yacc.c  */
+#line 384 "ldgram.y"
+    { (yyval.integer) = as_needed; as_needed = TRUE; }
+    break;
+
+  case 101:
+
+/* Line 1455 of yacc.c  */
+#line 386 "ldgram.y"
+    { as_needed = (yyvsp[(5) - (7)].integer); }
+    break;
+
+  case 102:
+
+/* Line 1455 of yacc.c  */
+#line 388 "ldgram.y"
+    { (yyval.integer) = as_needed; as_needed = TRUE; }
+    break;
+
+  case 103:
+
+/* Line 1455 of yacc.c  */
+#line 390 "ldgram.y"
+    { as_needed = (yyvsp[(4) - (6)].integer); }
+    break;
+
+  case 108:
+
+/* Line 1455 of yacc.c  */
+#line 405 "ldgram.y"
+    { lang_add_entry ((yyvsp[(3) - (4)].name), FALSE); }
+    break;
+
+  case 110:
+
+/* Line 1455 of yacc.c  */
+#line 407 "ldgram.y"
+    {ldlex_expression ();}
+    break;
+
+  case 111:
+
+/* Line 1455 of yacc.c  */
+#line 408 "ldgram.y"
+    { ldlex_popstate ();
+		  lang_add_assignment (exp_assert ((yyvsp[(4) - (7)].etree), (yyvsp[(6) - (7)].name))); }
+    break;
+
+  case 112:
+
+/* Line 1455 of yacc.c  */
+#line 416 "ldgram.y"
+    {
+			  (yyval.cname) = (yyvsp[(1) - (1)].name);
+			}
+    break;
+
+  case 113:
+
+/* Line 1455 of yacc.c  */
+#line 420 "ldgram.y"
+    {
+			  (yyval.cname) = "*";
+			}
+    break;
+
+  case 114:
+
+/* Line 1455 of yacc.c  */
+#line 424 "ldgram.y"
+    {
+			  (yyval.cname) = "?";
+			}
+    break;
+
+  case 115:
+
+/* Line 1455 of yacc.c  */
+#line 431 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(1) - (1)].cname);
+			  (yyval.wildcard).sorted = none;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 116:
+
+/* Line 1455 of yacc.c  */
+#line 437 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (5)].cname);
+			  (yyval.wildcard).sorted = none;
+			  (yyval.wildcard).exclude_name_list = (yyvsp[(3) - (5)].name_list);
+			}
+    break;
+
+  case 117:
+
+/* Line 1455 of yacc.c  */
+#line 443 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);
+			  (yyval.wildcard).sorted = by_name;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 118:
+
+/* Line 1455 of yacc.c  */
+#line 449 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);
+			  (yyval.wildcard).sorted = by_alignment;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 119:
+
+/* Line 1455 of yacc.c  */
+#line 455 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_name_alignment;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 120:
+
+/* Line 1455 of yacc.c  */
+#line 461 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_name;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 121:
+
+/* Line 1455 of yacc.c  */
+#line 467 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_alignment_name;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 122:
+
+/* Line 1455 of yacc.c  */
+#line 473 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_alignment;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 123:
+
+/* Line 1455 of yacc.c  */
+#line 479 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(7) - (8)].cname);
+			  (yyval.wildcard).sorted = by_name;
+			  (yyval.wildcard).exclude_name_list = (yyvsp[(5) - (8)].name_list);
+			}
+    break;
+
+  case 124:
+
+/* Line 1455 of yacc.c  */
+#line 488 "ldgram.y"
+    {
+			  struct name_list *tmp;
+			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
+			  tmp->name = (yyvsp[(2) - (2)].cname);
+			  tmp->next = (yyvsp[(1) - (2)].name_list);
+			  (yyval.name_list) = tmp;
+			}
+    break;
+
+  case 125:
+
+/* Line 1455 of yacc.c  */
+#line 497 "ldgram.y"
+    {
+			  struct name_list *tmp;
+			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
+			  tmp->name = (yyvsp[(1) - (1)].cname);
+			  tmp->next = NULL;
+			  (yyval.name_list) = tmp;
+			}
+    break;
+
+  case 126:
+
+/* Line 1455 of yacc.c  */
+#line 508 "ldgram.y"
+    {
+			  struct wildcard_list *tmp;
+			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
+			  tmp->next = (yyvsp[(1) - (3)].wildcard_list);
+			  tmp->spec = (yyvsp[(3) - (3)].wildcard);
+			  (yyval.wildcard_list) = tmp;
+			}
+    break;
+
+  case 127:
+
+/* Line 1455 of yacc.c  */
+#line 517 "ldgram.y"
+    {
+			  struct wildcard_list *tmp;
+			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
+			  tmp->next = NULL;
+			  tmp->spec = (yyvsp[(1) - (1)].wildcard);
+			  (yyval.wildcard_list) = tmp;
+			}
+    break;
+
+  case 128:
+
+/* Line 1455 of yacc.c  */
+#line 528 "ldgram.y"
+    {
+			  struct wildcard_spec tmp;
+			  tmp.name = (yyvsp[(1) - (1)].name);
+			  tmp.exclude_name_list = NULL;
+			  tmp.sorted = none;
+			  lang_add_wild (&tmp, NULL, ldgram_had_keep);
+			}
+    break;
+
+  case 129:
+
+/* Line 1455 of yacc.c  */
+#line 536 "ldgram.y"
+    {
+			  lang_add_wild (NULL, (yyvsp[(2) - (3)].wildcard_list), ldgram_had_keep);
+			}
+    break;
+
+  case 130:
+
+/* Line 1455 of yacc.c  */
+#line 540 "ldgram.y"
+    {
+			  lang_add_wild (&(yyvsp[(1) - (4)].wildcard), (yyvsp[(3) - (4)].wildcard_list), ldgram_had_keep);
+			}
+    break;
+
+  case 132:
+
+/* Line 1455 of yacc.c  */
+#line 548 "ldgram.y"
+    { ldgram_had_keep = TRUE; }
+    break;
+
+  case 133:
+
+/* Line 1455 of yacc.c  */
+#line 550 "ldgram.y"
+    { ldgram_had_keep = FALSE; }
+    break;
+
+  case 135:
+
+/* Line 1455 of yacc.c  */
+#line 556 "ldgram.y"
+    {
+ 		lang_add_attribute(lang_object_symbols_statement_enum);
+	      	}
+    break;
+
+  case 137:
+
+/* Line 1455 of yacc.c  */
+#line 561 "ldgram.y"
+    {
+
+		  lang_add_attribute(lang_constructors_statement_enum);
+		}
+    break;
+
+  case 138:
+
+/* Line 1455 of yacc.c  */
+#line 566 "ldgram.y"
+    {
+		  constructors_sorted = TRUE;
+		  lang_add_attribute (lang_constructors_statement_enum);
+		}
+    break;
+
+  case 140:
+
+/* Line 1455 of yacc.c  */
+#line 572 "ldgram.y"
+    {
+			  lang_add_data ((int) (yyvsp[(1) - (4)].integer), (yyvsp[(3) - (4)].etree));
+			}
+    break;
+
+  case 141:
+
+/* Line 1455 of yacc.c  */
+#line 577 "ldgram.y"
+    {
+			  lang_add_fill ((yyvsp[(3) - (4)].fill));
+			}
+    break;
+
+  case 142:
+
+/* Line 1455 of yacc.c  */
+#line 580 "ldgram.y"
+    {ldlex_expression ();}
+    break;
+
+  case 143:
+
+/* Line 1455 of yacc.c  */
+#line 581 "ldgram.y"
+    { ldlex_popstate ();
+			  lang_add_assignment (exp_assert ((yyvsp[(4) - (8)].etree), (yyvsp[(6) - (8)].name))); }
+    break;
+
+  case 144:
+
+/* Line 1455 of yacc.c  */
+#line 584 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 145:
+
+/* Line 1455 of yacc.c  */
+#line 586 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 150:
+
+/* Line 1455 of yacc.c  */
+#line 601 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 151:
+
+/* Line 1455 of yacc.c  */
+#line 603 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 152:
+
+/* Line 1455 of yacc.c  */
+#line 605 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 153:
+
+/* Line 1455 of yacc.c  */
+#line 607 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 154:
+
+/* Line 1455 of yacc.c  */
+#line 609 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 155:
+
+/* Line 1455 of yacc.c  */
+#line 614 "ldgram.y"
+    {
+		  (yyval.fill) = exp_get_fill ((yyvsp[(1) - (1)].etree), 0, "fill value");
+		}
+    break;
+
+  case 156:
+
+/* Line 1455 of yacc.c  */
+#line 621 "ldgram.y"
+    { (yyval.fill) = (yyvsp[(2) - (2)].fill); }
+    break;
+
+  case 157:
+
+/* Line 1455 of yacc.c  */
+#line 622 "ldgram.y"
+    { (yyval.fill) = (fill_type *) 0; }
+    break;
+
+  case 158:
+
+/* Line 1455 of yacc.c  */
+#line 627 "ldgram.y"
+    { (yyval.token) = '+'; }
+    break;
+
+  case 159:
+
+/* Line 1455 of yacc.c  */
+#line 629 "ldgram.y"
+    { (yyval.token) = '-'; }
+    break;
+
+  case 160:
+
+/* Line 1455 of yacc.c  */
+#line 631 "ldgram.y"
+    { (yyval.token) = '*'; }
+    break;
+
+  case 161:
+
+/* Line 1455 of yacc.c  */
+#line 633 "ldgram.y"
+    { (yyval.token) = '/'; }
+    break;
+
+  case 162:
+
+/* Line 1455 of yacc.c  */
+#line 635 "ldgram.y"
+    { (yyval.token) = LSHIFT; }
+    break;
+
+  case 163:
+
+/* Line 1455 of yacc.c  */
+#line 637 "ldgram.y"
+    { (yyval.token) = RSHIFT; }
+    break;
+
+  case 164:
+
+/* Line 1455 of yacc.c  */
+#line 639 "ldgram.y"
+    { (yyval.token) = '&'; }
+    break;
+
+  case 165:
+
+/* Line 1455 of yacc.c  */
+#line 641 "ldgram.y"
+    { (yyval.token) = '|'; }
+    break;
+
+  case 168:
+
+/* Line 1455 of yacc.c  */
+#line 651 "ldgram.y"
+    {
+		  lang_add_assignment (exp_assop ((yyvsp[(2) - (3)].token), (yyvsp[(1) - (3)].name), (yyvsp[(3) - (3)].etree)));
+		}
+    break;
+
+  case 169:
+
+/* Line 1455 of yacc.c  */
+#line 655 "ldgram.y"
+    {
+		  lang_add_assignment (exp_assop ('=', (yyvsp[(1) - (3)].name),
+						  exp_binop ((yyvsp[(2) - (3)].token),
+							     exp_nameop (NAME,
+									 (yyvsp[(1) - (3)].name)),
+							     (yyvsp[(3) - (3)].etree))));
+		}
+    break;
+
+  case 170:
+
+/* Line 1455 of yacc.c  */
+#line 663 "ldgram.y"
+    {
+		  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), FALSE));
+		}
+    break;
+
+  case 171:
+
+/* Line 1455 of yacc.c  */
+#line 667 "ldgram.y"
+    {
+		  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), TRUE));
+		}
+    break;
+
+  case 179:
+
+/* Line 1455 of yacc.c  */
+#line 690 "ldgram.y"
+    { region = lang_memory_region_lookup ((yyvsp[(1) - (1)].name), TRUE); }
+    break;
+
+  case 180:
+
+/* Line 1455 of yacc.c  */
+#line 693 "ldgram.y"
+    {}
+    break;
+
+  case 181:
+
+/* Line 1455 of yacc.c  */
+#line 695 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 182:
+
+/* Line 1455 of yacc.c  */
+#line 697 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 183:
+
+/* Line 1455 of yacc.c  */
+#line 702 "ldgram.y"
+    {
+		  region->origin = exp_get_vma ((yyvsp[(3) - (3)].etree), 0, "origin");
+		  region->current = region->origin;
+		}
+    break;
+
+  case 184:
+
+/* Line 1455 of yacc.c  */
+#line 710 "ldgram.y"
+    {
+		  region->length = exp_get_vma ((yyvsp[(3) - (3)].etree), -1, "length");
+		}
+    break;
+
+  case 185:
+
+/* Line 1455 of yacc.c  */
+#line 717 "ldgram.y"
+    { /* dummy action to avoid bison 1.25 error message */ }
+    break;
+
+  case 189:
+
+/* Line 1455 of yacc.c  */
+#line 728 "ldgram.y"
+    { lang_set_flags (region, (yyvsp[(1) - (1)].name), 0); }
+    break;
+
+  case 190:
+
+/* Line 1455 of yacc.c  */
+#line 730 "ldgram.y"
+    { lang_set_flags (region, (yyvsp[(2) - (2)].name), 1); }
+    break;
+
+  case 191:
+
+/* Line 1455 of yacc.c  */
+#line 735 "ldgram.y"
+    { lang_startup((yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 193:
+
+/* Line 1455 of yacc.c  */
+#line 741 "ldgram.y"
+    { ldemul_hll((char *)NULL); }
+    break;
+
+  case 194:
+
+/* Line 1455 of yacc.c  */
+#line 746 "ldgram.y"
+    { ldemul_hll((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 195:
+
+/* Line 1455 of yacc.c  */
+#line 748 "ldgram.y"
+    { ldemul_hll((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 197:
+
+/* Line 1455 of yacc.c  */
+#line 756 "ldgram.y"
+    { ldemul_syslib((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 199:
+
+/* Line 1455 of yacc.c  */
+#line 762 "ldgram.y"
+    { lang_float(TRUE); }
+    break;
+
+  case 200:
+
+/* Line 1455 of yacc.c  */
+#line 764 "ldgram.y"
+    { lang_float(FALSE); }
+    break;
+
+  case 201:
+
+/* Line 1455 of yacc.c  */
+#line 769 "ldgram.y"
+    {
+		  (yyval.nocrossref) = NULL;
+		}
+    break;
+
+  case 202:
+
+/* Line 1455 of yacc.c  */
+#line 773 "ldgram.y"
+    {
+		  struct lang_nocrossref *n;
+
+		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
+		  n->name = (yyvsp[(1) - (2)].name);
+		  n->next = (yyvsp[(2) - (2)].nocrossref);
+		  (yyval.nocrossref) = n;
+		}
+    break;
+
+  case 203:
+
+/* Line 1455 of yacc.c  */
+#line 782 "ldgram.y"
+    {
+		  struct lang_nocrossref *n;
+
+		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
+		  n->name = (yyvsp[(1) - (3)].name);
+		  n->next = (yyvsp[(3) - (3)].nocrossref);
+		  (yyval.nocrossref) = n;
+		}
+    break;
+
+  case 204:
+
+/* Line 1455 of yacc.c  */
+#line 792 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 205:
+
+/* Line 1455 of yacc.c  */
+#line 794 "ldgram.y"
+    { ldlex_popstate (); (yyval.etree)=(yyvsp[(2) - (2)].etree);}
+    break;
+
+  case 206:
+
+/* Line 1455 of yacc.c  */
+#line 799 "ldgram.y"
+    { (yyval.etree) = exp_unop ('-', (yyvsp[(2) - (2)].etree)); }
+    break;
+
+  case 207:
+
+/* Line 1455 of yacc.c  */
+#line 801 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(2) - (3)].etree); }
+    break;
+
+  case 208:
+
+/* Line 1455 of yacc.c  */
+#line 803 "ldgram.y"
+    { (yyval.etree) = exp_unop ((int) (yyvsp[(1) - (4)].integer),(yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 209:
+
+/* Line 1455 of yacc.c  */
+#line 805 "ldgram.y"
+    { (yyval.etree) = exp_unop ('!', (yyvsp[(2) - (2)].etree)); }
+    break;
+
+  case 210:
+
+/* Line 1455 of yacc.c  */
+#line 807 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(2) - (2)].etree); }
+    break;
+
+  case 211:
+
+/* Line 1455 of yacc.c  */
+#line 809 "ldgram.y"
+    { (yyval.etree) = exp_unop ('~', (yyvsp[(2) - (2)].etree));}
+    break;
+
+  case 212:
+
+/* Line 1455 of yacc.c  */
+#line 812 "ldgram.y"
+    { (yyval.etree) = exp_binop ('*', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 213:
+
+/* Line 1455 of yacc.c  */
+#line 814 "ldgram.y"
+    { (yyval.etree) = exp_binop ('/', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 214:
+
+/* Line 1455 of yacc.c  */
+#line 816 "ldgram.y"
+    { (yyval.etree) = exp_binop ('%', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 215:
+
+/* Line 1455 of yacc.c  */
+#line 818 "ldgram.y"
+    { (yyval.etree) = exp_binop ('+', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 216:
+
+/* Line 1455 of yacc.c  */
+#line 820 "ldgram.y"
+    { (yyval.etree) = exp_binop ('-' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 217:
+
+/* Line 1455 of yacc.c  */
+#line 822 "ldgram.y"
+    { (yyval.etree) = exp_binop (LSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 218:
+
+/* Line 1455 of yacc.c  */
+#line 824 "ldgram.y"
+    { (yyval.etree) = exp_binop (RSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 219:
+
+/* Line 1455 of yacc.c  */
+#line 826 "ldgram.y"
+    { (yyval.etree) = exp_binop (EQ , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 220:
+
+/* Line 1455 of yacc.c  */
+#line 828 "ldgram.y"
+    { (yyval.etree) = exp_binop (NE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 221:
+
+/* Line 1455 of yacc.c  */
+#line 830 "ldgram.y"
+    { (yyval.etree) = exp_binop (LE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 222:
+
+/* Line 1455 of yacc.c  */
+#line 832 "ldgram.y"
+    { (yyval.etree) = exp_binop (GE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 223:
+
+/* Line 1455 of yacc.c  */
+#line 834 "ldgram.y"
+    { (yyval.etree) = exp_binop ('<' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 224:
+
+/* Line 1455 of yacc.c  */
+#line 836 "ldgram.y"
+    { (yyval.etree) = exp_binop ('>' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 225:
+
+/* Line 1455 of yacc.c  */
+#line 838 "ldgram.y"
+    { (yyval.etree) = exp_binop ('&' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 226:
+
+/* Line 1455 of yacc.c  */
+#line 840 "ldgram.y"
+    { (yyval.etree) = exp_binop ('^' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 227:
+
+/* Line 1455 of yacc.c  */
+#line 842 "ldgram.y"
+    { (yyval.etree) = exp_binop ('|' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 228:
+
+/* Line 1455 of yacc.c  */
+#line 844 "ldgram.y"
+    { (yyval.etree) = exp_trinop ('?' , (yyvsp[(1) - (5)].etree), (yyvsp[(3) - (5)].etree), (yyvsp[(5) - (5)].etree)); }
+    break;
+
+  case 229:
+
+/* Line 1455 of yacc.c  */
+#line 846 "ldgram.y"
+    { (yyval.etree) = exp_binop (ANDAND , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 230:
+
+/* Line 1455 of yacc.c  */
+#line 848 "ldgram.y"
+    { (yyval.etree) = exp_binop (OROR , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 231:
+
+/* Line 1455 of yacc.c  */
+#line 850 "ldgram.y"
+    { (yyval.etree) = exp_nameop (DEFINED, (yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 232:
+
+/* Line 1455 of yacc.c  */
+#line 852 "ldgram.y"
+    { (yyval.etree) = exp_bigintop ((yyvsp[(1) - (1)].bigint).integer, (yyvsp[(1) - (1)].bigint).str); }
+    break;
+
+  case 233:
+
+/* Line 1455 of yacc.c  */
+#line 854 "ldgram.y"
+    { (yyval.etree) = exp_nameop (SIZEOF_HEADERS,0); }
+    break;
+
+  case 234:
+
+/* Line 1455 of yacc.c  */
+#line 857 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ALIGNOF,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 235:
+
+/* Line 1455 of yacc.c  */
+#line 859 "ldgram.y"
+    { (yyval.etree) = exp_nameop (SIZEOF,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 236:
+
+/* Line 1455 of yacc.c  */
+#line 861 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ADDR,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 237:
+
+/* Line 1455 of yacc.c  */
+#line 863 "ldgram.y"
+    { (yyval.etree) = exp_nameop (LOADADDR,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 238:
+
+/* Line 1455 of yacc.c  */
+#line 865 "ldgram.y"
+    { (yyval.etree) = exp_nameop (CONSTANT,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 239:
+
+/* Line 1455 of yacc.c  */
+#line 867 "ldgram.y"
+    { (yyval.etree) = exp_unop (ABSOLUTE, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 240:
+
+/* Line 1455 of yacc.c  */
+#line 869 "ldgram.y"
+    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 241:
+
+/* Line 1455 of yacc.c  */
+#line 871 "ldgram.y"
+    { (yyval.etree) = exp_binop (ALIGN_K,(yyvsp[(3) - (6)].etree),(yyvsp[(5) - (6)].etree)); }
+    break;
+
+  case 242:
+
+/* Line 1455 of yacc.c  */
+#line 873 "ldgram.y"
+    { (yyval.etree) = exp_binop (DATA_SEGMENT_ALIGN, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree)); }
+    break;
+
+  case 243:
+
+/* Line 1455 of yacc.c  */
+#line 875 "ldgram.y"
+    { (yyval.etree) = exp_binop (DATA_SEGMENT_RELRO_END, (yyvsp[(5) - (6)].etree), (yyvsp[(3) - (6)].etree)); }
+    break;
+
+  case 244:
+
+/* Line 1455 of yacc.c  */
+#line 877 "ldgram.y"
+    { (yyval.etree) = exp_unop (DATA_SEGMENT_END, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 245:
+
+/* Line 1455 of yacc.c  */
+#line 879 "ldgram.y"
+    { /* The operands to the expression node are
+			     placed in the opposite order from the way
+			     in which they appear in the script as
+			     that allows us to reuse more code in
+			     fold_binary.  */
+			  (yyval.etree) = exp_binop (SEGMENT_START,
+					  (yyvsp[(5) - (6)].etree),
+					  exp_nameop (NAME, (yyvsp[(3) - (6)].name))); }
+    break;
+
+  case 246:
+
+/* Line 1455 of yacc.c  */
+#line 888 "ldgram.y"
+    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 247:
+
+/* Line 1455 of yacc.c  */
+#line 890 "ldgram.y"
+    { (yyval.etree) = exp_nameop (NAME,(yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 248:
+
+/* Line 1455 of yacc.c  */
+#line 892 "ldgram.y"
+    { (yyval.etree) = exp_binop (MAX_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree) ); }
+    break;
+
+  case 249:
+
+/* Line 1455 of yacc.c  */
+#line 894 "ldgram.y"
+    { (yyval.etree) = exp_binop (MIN_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree) ); }
+    break;
+
+  case 250:
+
+/* Line 1455 of yacc.c  */
+#line 896 "ldgram.y"
+    { (yyval.etree) = exp_unop (CEILP2, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 251:
+
+/* Line 1455 of yacc.c  */
+#line 898 "ldgram.y"
+    { (yyval.etree) = exp_unop (NACL_MASK, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 252:
+
+/* Line 1455 of yacc.c  */
+#line 900 "ldgram.y"
+    { (yyval.etree) = exp_assert ((yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].name)); }
+    break;
+
+  case 253:
+
+/* Line 1455 of yacc.c  */
+#line 902 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ORIGIN, (yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 254:
+
+/* Line 1455 of yacc.c  */
+#line 904 "ldgram.y"
+    { (yyval.etree) = exp_nameop (LENGTH, (yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 255:
+
+/* Line 1455 of yacc.c  */
+#line 909 "ldgram.y"
+    { (yyval.name) = (yyvsp[(3) - (3)].name); }
+    break;
+
+  case 256:
+
+/* Line 1455 of yacc.c  */
+#line 910 "ldgram.y"
+    { (yyval.name) = 0; }
+    break;
+
+  case 257:
+
+/* Line 1455 of yacc.c  */
+#line 914 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+    break;
+
+  case 258:
+
+/* Line 1455 of yacc.c  */
+#line 915 "ldgram.y"
+    { (yyval.etree) = 0; }
+    break;
+
+  case 259:
+
+/* Line 1455 of yacc.c  */
+#line 919 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+    break;
+
+  case 260:
+
+/* Line 1455 of yacc.c  */
+#line 920 "ldgram.y"
+    { (yyval.etree) = 0; }
+    break;
+
+  case 261:
+
+/* Line 1455 of yacc.c  */
+#line 924 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+    break;
+
+  case 262:
+
+/* Line 1455 of yacc.c  */
+#line 925 "ldgram.y"
+    { (yyval.etree) = 0; }
+    break;
+
+  case 263:
+
+/* Line 1455 of yacc.c  */
+#line 929 "ldgram.y"
+    { (yyval.token) = ONLY_IF_RO; }
+    break;
+
+  case 264:
+
+/* Line 1455 of yacc.c  */
+#line 930 "ldgram.y"
+    { (yyval.token) = ONLY_IF_RW; }
+    break;
+
+  case 265:
+
+/* Line 1455 of yacc.c  */
+#line 931 "ldgram.y"
+    { (yyval.token) = SPECIAL; }
+    break;
+
+  case 266:
+
+/* Line 1455 of yacc.c  */
+#line 932 "ldgram.y"
+    { (yyval.token) = 0; }
+    break;
+
+  case 267:
+
+/* Line 1455 of yacc.c  */
+#line 935 "ldgram.y"
+    { ldlex_expression(); }
+    break;
+
+  case 268:
+
+/* Line 1455 of yacc.c  */
+#line 939 "ldgram.y"
+    { ldlex_popstate (); ldlex_script (); }
+    break;
+
+  case 269:
+
+/* Line 1455 of yacc.c  */
+#line 942 "ldgram.y"
+    {
+			  lang_enter_output_section_statement((yyvsp[(1) - (9)].name), (yyvsp[(3) - (9)].etree),
+							      sectype,
+							      (yyvsp[(5) - (9)].etree), (yyvsp[(6) - (9)].etree), (yyvsp[(4) - (9)].etree), (yyvsp[(8) - (9)].token));
+			}
+    break;
+
+  case 270:
+
+/* Line 1455 of yacc.c  */
+#line 948 "ldgram.y"
+    { ldlex_popstate (); ldlex_expression (); }
+    break;
+
+  case 271:
+
+/* Line 1455 of yacc.c  */
+#line 950 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  lang_leave_output_section_statement ((yyvsp[(17) - (17)].fill), (yyvsp[(14) - (17)].name), (yyvsp[(16) - (17)].section_phdr), (yyvsp[(15) - (17)].name));
+		}
+    break;
+
+  case 272:
+
+/* Line 1455 of yacc.c  */
+#line 955 "ldgram.y"
+    {}
+    break;
+
+  case 273:
+
+/* Line 1455 of yacc.c  */
+#line 957 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 274:
+
+/* Line 1455 of yacc.c  */
+#line 959 "ldgram.y"
+    { ldlex_popstate (); ldlex_script (); }
+    break;
+
+  case 275:
+
+/* Line 1455 of yacc.c  */
+#line 961 "ldgram.y"
+    {
+			  lang_enter_overlay ((yyvsp[(3) - (8)].etree), (yyvsp[(6) - (8)].etree));
+			}
+    break;
+
+  case 276:
+
+/* Line 1455 of yacc.c  */
+#line 966 "ldgram.y"
+    { ldlex_popstate (); ldlex_expression (); }
+    break;
+
+  case 277:
+
+/* Line 1455 of yacc.c  */
+#line 968 "ldgram.y"
+    {
+			  ldlex_popstate ();
+			  lang_leave_overlay ((yyvsp[(5) - (16)].etree), (int) (yyvsp[(4) - (16)].integer),
+					      (yyvsp[(16) - (16)].fill), (yyvsp[(13) - (16)].name), (yyvsp[(15) - (16)].section_phdr), (yyvsp[(14) - (16)].name));
+			}
+    break;
+
+  case 279:
+
+/* Line 1455 of yacc.c  */
+#line 978 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 280:
+
+/* Line 1455 of yacc.c  */
+#line 980 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  lang_add_assignment (exp_assop ('=', ".", (yyvsp[(3) - (3)].etree)));
+		}
+    break;
+
+  case 282:
+
+/* Line 1455 of yacc.c  */
+#line 986 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 283:
+
+/* Line 1455 of yacc.c  */
+#line 988 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 284:
+
+/* Line 1455 of yacc.c  */
+#line 992 "ldgram.y"
+    { sectype = noload_section; }
+    break;
+
+  case 285:
+
+/* Line 1455 of yacc.c  */
+#line 993 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 286:
+
+/* Line 1455 of yacc.c  */
+#line 994 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 287:
+
+/* Line 1455 of yacc.c  */
+#line 995 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 288:
+
+/* Line 1455 of yacc.c  */
+#line 996 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 290:
+
+/* Line 1455 of yacc.c  */
+#line 1001 "ldgram.y"
+    { sectype = normal_section; }
+    break;
+
+  case 291:
+
+/* Line 1455 of yacc.c  */
+#line 1002 "ldgram.y"
+    { sectype = normal_section; }
+    break;
+
+  case 292:
+
+/* Line 1455 of yacc.c  */
+#line 1006 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(1) - (3)].etree); }
+    break;
+
+  case 293:
+
+/* Line 1455 of yacc.c  */
+#line 1007 "ldgram.y"
+    { (yyval.etree) = (etree_type *)NULL;  }
+    break;
+
+  case 294:
+
+/* Line 1455 of yacc.c  */
+#line 1012 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (6)].etree); }
+    break;
+
+  case 295:
+
+/* Line 1455 of yacc.c  */
+#line 1014 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (10)].etree); }
+    break;
+
+  case 296:
+
+/* Line 1455 of yacc.c  */
+#line 1018 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(1) - (2)].etree); }
+    break;
+
+  case 297:
+
+/* Line 1455 of yacc.c  */
+#line 1019 "ldgram.y"
+    { (yyval.etree) = (etree_type *) NULL;  }
+    break;
+
+  case 298:
+
+/* Line 1455 of yacc.c  */
+#line 1024 "ldgram.y"
+    { (yyval.integer) = 0; }
+    break;
+
+  case 299:
+
+/* Line 1455 of yacc.c  */
+#line 1026 "ldgram.y"
+    { (yyval.integer) = 1; }
+    break;
+
+  case 300:
+
+/* Line 1455 of yacc.c  */
+#line 1031 "ldgram.y"
+    { (yyval.name) = (yyvsp[(2) - (2)].name); }
+    break;
+
+  case 301:
+
+/* Line 1455 of yacc.c  */
+#line 1032 "ldgram.y"
+    { (yyval.name) = DEFAULT_MEMORY_REGION; }
+    break;
+
+  case 302:
+
+/* Line 1455 of yacc.c  */
+#line 1037 "ldgram.y"
+    {
+		  (yyval.section_phdr) = NULL;
+		}
+    break;
+
+  case 303:
+
+/* Line 1455 of yacc.c  */
+#line 1041 "ldgram.y"
+    {
+		  struct lang_output_section_phdr_list *n;
+
+		  n = ((struct lang_output_section_phdr_list *)
+		       xmalloc (sizeof *n));
+		  n->name = (yyvsp[(3) - (3)].name);
+		  n->used = FALSE;
+		  n->next = (yyvsp[(1) - (3)].section_phdr);
+		  (yyval.section_phdr) = n;
+		}
+    break;
+
+  case 305:
+
+/* Line 1455 of yacc.c  */
+#line 1057 "ldgram.y"
+    {
+			  ldlex_script ();
+			  lang_enter_overlay_section ((yyvsp[(2) - (2)].name));
+			}
+    break;
+
+  case 306:
+
+/* Line 1455 of yacc.c  */
+#line 1062 "ldgram.y"
+    { ldlex_popstate (); ldlex_expression (); }
+    break;
+
+  case 307:
+
+/* Line 1455 of yacc.c  */
+#line 1064 "ldgram.y"
+    {
+			  ldlex_popstate ();
+			  lang_leave_overlay_section ((yyvsp[(9) - (9)].fill), (yyvsp[(8) - (9)].section_phdr));
+			}
+    break;
+
+  case 312:
+
+/* Line 1455 of yacc.c  */
+#line 1081 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 313:
+
+/* Line 1455 of yacc.c  */
+#line 1082 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 314:
+
+/* Line 1455 of yacc.c  */
+#line 1084 "ldgram.y"
+    {
+		  lang_new_phdr ((yyvsp[(1) - (6)].name), (yyvsp[(3) - (6)].etree), (yyvsp[(4) - (6)].phdr).filehdr, (yyvsp[(4) - (6)].phdr).phdrs, (yyvsp[(4) - (6)].phdr).at,
+				 (yyvsp[(4) - (6)].phdr).flags);
+		}
+    break;
+
+  case 315:
+
+/* Line 1455 of yacc.c  */
+#line 1092 "ldgram.y"
+    {
+		  (yyval.etree) = (yyvsp[(1) - (1)].etree);
+
+		  if ((yyvsp[(1) - (1)].etree)->type.node_class == etree_name
+		      && (yyvsp[(1) - (1)].etree)->type.node_code == NAME)
+		    {
+		      const char *s;
+		      unsigned int i;
+		      static const char * const phdr_types[] =
+			{
+			  "PT_NULL", "PT_LOAD", "PT_DYNAMIC",
+			  "PT_INTERP", "PT_NOTE", "PT_SHLIB",
+			  "PT_PHDR", "PT_TLS"
+			};
+
+		      s = (yyvsp[(1) - (1)].etree)->name.name;
+		      for (i = 0;
+			   i < sizeof phdr_types / sizeof phdr_types[0];
+			   i++)
+			if (strcmp (s, phdr_types[i]) == 0)
+			  {
+			    (yyval.etree) = exp_intop (i);
+			    break;
+			  }
+		      if (i == sizeof phdr_types / sizeof phdr_types[0])
+			{
+			  if (strcmp (s, "PT_GNU_EH_FRAME") == 0)
+			    (yyval.etree) = exp_intop (0x6474e550);
+			  else if (strcmp (s, "PT_GNU_STACK") == 0)
+			    (yyval.etree) = exp_intop (0x6474e551);
+			  else
+			    {
+			      einfo (_("\
+%X%P:%S: unknown phdr type `%s' (try integer literal)\n"),
+				     s);
+			      (yyval.etree) = exp_intop (0);
+			    }
+			}
+		    }
+		}
+    break;
+
+  case 316:
+
+/* Line 1455 of yacc.c  */
+#line 1136 "ldgram.y"
+    {
+		  memset (&(yyval.phdr), 0, sizeof (struct phdr_info));
+		}
+    break;
+
+  case 317:
+
+/* Line 1455 of yacc.c  */
+#line 1140 "ldgram.y"
+    {
+		  (yyval.phdr) = (yyvsp[(3) - (3)].phdr);
+		  if (strcmp ((yyvsp[(1) - (3)].name), "FILEHDR") == 0 && (yyvsp[(2) - (3)].etree) == NULL)
+		    (yyval.phdr).filehdr = TRUE;
+		  else if (strcmp ((yyvsp[(1) - (3)].name), "PHDRS") == 0 && (yyvsp[(2) - (3)].etree) == NULL)
+		    (yyval.phdr).phdrs = TRUE;
+		  else if (strcmp ((yyvsp[(1) - (3)].name), "FLAGS") == 0 && (yyvsp[(2) - (3)].etree) != NULL)
+		    (yyval.phdr).flags = (yyvsp[(2) - (3)].etree);
+		  else
+		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), (yyvsp[(1) - (3)].name));
+		}
+    break;
+
+  case 318:
+
+/* Line 1455 of yacc.c  */
+#line 1152 "ldgram.y"
+    {
+		  (yyval.phdr) = (yyvsp[(5) - (5)].phdr);
+		  (yyval.phdr).at = (yyvsp[(3) - (5)].etree);
+		}
+    break;
+
+  case 319:
+
+/* Line 1455 of yacc.c  */
+#line 1160 "ldgram.y"
+    {
+		  (yyval.etree) = NULL;
+		}
+    break;
+
+  case 320:
+
+/* Line 1455 of yacc.c  */
+#line 1164 "ldgram.y"
+    {
+		  (yyval.etree) = (yyvsp[(2) - (3)].etree);
+		}
+    break;
+
+  case 321:
+
+/* Line 1455 of yacc.c  */
+#line 1170 "ldgram.y"
+    {
+		  ldlex_version_file ();
+		  PUSH_ERROR (_("dynamic list"));
+		}
+    break;
+
+  case 322:
+
+/* Line 1455 of yacc.c  */
+#line 1175 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  POP_ERROR ();
+		}
+    break;
+
+  case 326:
+
+/* Line 1455 of yacc.c  */
+#line 1192 "ldgram.y"
+    {
+		  lang_append_dynamic_list ((yyvsp[(1) - (2)].versyms));
+		}
+    break;
+
+  case 327:
+
+/* Line 1455 of yacc.c  */
+#line 1200 "ldgram.y"
+    {
+		  ldlex_version_file ();
+		  PUSH_ERROR (_("VERSION script"));
+		}
+    break;
+
+  case 328:
+
+/* Line 1455 of yacc.c  */
+#line 1205 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  POP_ERROR ();
+		}
+    break;
+
+  case 329:
+
+/* Line 1455 of yacc.c  */
+#line 1214 "ldgram.y"
+    {
+		  ldlex_version_script ();
+		}
+    break;
+
+  case 330:
+
+/* Line 1455 of yacc.c  */
+#line 1218 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		}
+    break;
+
+  case 333:
+
+/* Line 1455 of yacc.c  */
+#line 1230 "ldgram.y"
+    {
+		  lang_register_vers_node (NULL, (yyvsp[(2) - (4)].versnode), NULL);
+		}
+    break;
+
+  case 334:
+
+/* Line 1455 of yacc.c  */
+#line 1234 "ldgram.y"
+    {
+		  lang_register_vers_node ((yyvsp[(1) - (5)].name), (yyvsp[(3) - (5)].versnode), NULL);
+		}
+    break;
+
+  case 335:
+
+/* Line 1455 of yacc.c  */
+#line 1238 "ldgram.y"
+    {
+		  lang_register_vers_node ((yyvsp[(1) - (6)].name), (yyvsp[(3) - (6)].versnode), (yyvsp[(5) - (6)].deflist));
+		}
+    break;
+
+  case 336:
+
+/* Line 1455 of yacc.c  */
+#line 1245 "ldgram.y"
+    {
+		  (yyval.deflist) = lang_add_vers_depend (NULL, (yyvsp[(1) - (1)].name));
+		}
+    break;
+
+  case 337:
+
+/* Line 1455 of yacc.c  */
+#line 1249 "ldgram.y"
+    {
+		  (yyval.deflist) = lang_add_vers_depend ((yyvsp[(1) - (2)].deflist), (yyvsp[(2) - (2)].name));
+		}
+    break;
+
+  case 338:
+
+/* Line 1455 of yacc.c  */
+#line 1256 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node (NULL, NULL);
+		}
+    break;
+
+  case 339:
+
+/* Line 1455 of yacc.c  */
+#line 1260 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(1) - (2)].versyms), NULL);
+		}
+    break;
+
+  case 340:
+
+/* Line 1455 of yacc.c  */
+#line 1264 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(3) - (4)].versyms), NULL);
+		}
+    break;
+
+  case 341:
+
+/* Line 1455 of yacc.c  */
+#line 1268 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node (NULL, (yyvsp[(3) - (4)].versyms));
+		}
+    break;
+
+  case 342:
+
+/* Line 1455 of yacc.c  */
+#line 1272 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(3) - (8)].versyms), (yyvsp[(7) - (8)].versyms));
+		}
+    break;
+
+  case 343:
+
+/* Line 1455 of yacc.c  */
+#line 1279 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[(1) - (1)].name), ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 344:
+
+/* Line 1455 of yacc.c  */
+#line 1283 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[(1) - (1)].name), ldgram_vers_current_lang, TRUE);
+		}
+    break;
+
+  case 345:
+
+/* Line 1455 of yacc.c  */
+#line 1287 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), (yyvsp[(3) - (3)].name), ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 346:
+
+/* Line 1455 of yacc.c  */
+#line 1291 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), (yyvsp[(3) - (3)].name), ldgram_vers_current_lang, TRUE);
+		}
+    break;
+
+  case 347:
+
+/* Line 1455 of yacc.c  */
+#line 1295 "ldgram.y"
+    {
+			  (yyval.name) = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = (yyvsp[(4) - (5)].name);
+			}
+    break;
+
+  case 348:
+
+/* Line 1455 of yacc.c  */
+#line 1300 "ldgram.y"
+    {
+			  struct bfd_elf_version_expr *pat;
+			  for (pat = (yyvsp[(7) - (9)].versyms); pat->next != NULL; pat = pat->next);
+			  pat->next = (yyvsp[(1) - (9)].versyms);
+			  (yyval.versyms) = (yyvsp[(7) - (9)].versyms);
+			  ldgram_vers_current_lang = (yyvsp[(6) - (9)].name);
+			}
+    break;
+
+  case 349:
+
+/* Line 1455 of yacc.c  */
+#line 1308 "ldgram.y"
+    {
+			  (yyval.name) = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = (yyvsp[(2) - (3)].name);
+			}
+    break;
+
+  case 350:
+
+/* Line 1455 of yacc.c  */
+#line 1313 "ldgram.y"
+    {
+			  (yyval.versyms) = (yyvsp[(5) - (7)].versyms);
+			  ldgram_vers_current_lang = (yyvsp[(4) - (7)].name);
+			}
+    break;
+
+  case 351:
+
+/* Line 1455 of yacc.c  */
+#line 1318 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 352:
+
+/* Line 1455 of yacc.c  */
+#line 1322 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "global", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 353:
+
+/* Line 1455 of yacc.c  */
+#line 1326 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 354:
+
+/* Line 1455 of yacc.c  */
+#line 1330 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "local", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 355:
+
+/* Line 1455 of yacc.c  */
+#line 1334 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 356:
+
+/* Line 1455 of yacc.c  */
+#line 1338 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "extern", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 4867 "ldgram.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 1348 "ldgram.y"
+
+void
+yyerror(arg)
+     const char *arg;
+{
+  if (ldfile_assumed_script)
+    einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
+	   ldfile_input_filename);
+  if (error_index > 0 && error_index < ERROR_NAME_MAX)
+     einfo ("%P%F:%S: %s in %s\n", arg, error_names[error_index-1]);
+  else
+     einfo ("%P%F:%S: %s\n", arg);
+}
+
diff -uNr binutils-2.19.51.20090622.orig/ld/ldgram.h binutils-2.19.51.20090622/ld/ldgram.h
--- binutils-2.19.51.20090622.orig/ld/ldgram.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.19.51.20090622/ld/ldgram.h	2009-06-28 17:16:42.000000000 +0200
@@ -0,0 +1,341 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     INT = 258,
+     NAME = 259,
+     LNAME = 260,
+     OREQ = 261,
+     ANDEQ = 262,
+     RSHIFTEQ = 263,
+     LSHIFTEQ = 264,
+     DIVEQ = 265,
+     MULTEQ = 266,
+     MINUSEQ = 267,
+     PLUSEQ = 268,
+     OROR = 269,
+     ANDAND = 270,
+     NE = 271,
+     EQ = 272,
+     GE = 273,
+     LE = 274,
+     RSHIFT = 275,
+     LSHIFT = 276,
+     UNARY = 277,
+     END = 278,
+     ALIGN_K = 279,
+     BLOCK = 280,
+     BIND = 281,
+     QUAD = 282,
+     SQUAD = 283,
+     LONG = 284,
+     SHORT = 285,
+     BYTE = 286,
+     SECTIONS = 287,
+     PHDRS = 288,
+     INSERT_K = 289,
+     AFTER = 290,
+     BEFORE = 291,
+     DATA_SEGMENT_ALIGN = 292,
+     DATA_SEGMENT_RELRO_END = 293,
+     DATA_SEGMENT_END = 294,
+     SORT_BY_NAME = 295,
+     SORT_BY_ALIGNMENT = 296,
+     SIZEOF_HEADERS = 297,
+     OUTPUT_FORMAT = 298,
+     FORCE_COMMON_ALLOCATION = 299,
+     OUTPUT_ARCH = 300,
+     INHIBIT_COMMON_ALLOCATION = 301,
+     SEGMENT_START = 302,
+     INCLUDE = 303,
+     MEMORY = 304,
+     REGION_ALIAS = 305,
+     NOLOAD = 306,
+     DSECT = 307,
+     COPY = 308,
+     INFO = 309,
+     OVERLAY = 310,
+     DEFINED = 311,
+     TARGET_K = 312,
+     SEARCH_DIR = 313,
+     MAP = 314,
+     ENTRY = 315,
+     NEXT = 316,
+     SIZEOF = 317,
+     ALIGNOF = 318,
+     ADDR = 319,
+     LOADADDR = 320,
+     MAX_K = 321,
+     MIN_K = 322,
+     CEILP2 = 323,
+     NACL_MASK = 324,
+     STARTUP = 325,
+     HLL = 326,
+     SYSLIB = 327,
+     FLOAT = 328,
+     NOFLOAT = 329,
+     NOCROSSREFS = 330,
+     ORIGIN = 331,
+     FILL = 332,
+     LENGTH = 333,
+     CREATE_OBJECT_SYMBOLS = 334,
+     INPUT = 335,
+     GROUP = 336,
+     OUTPUT = 337,
+     CONSTRUCTORS = 338,
+     ALIGNMOD = 339,
+     AT = 340,
+     SUBALIGN = 341,
+     PROVIDE = 342,
+     PROVIDE_HIDDEN = 343,
+     AS_NEEDED = 344,
+     CHIP = 345,
+     LIST = 346,
+     SECT = 347,
+     ABSOLUTE = 348,
+     LOAD = 349,
+     NEWLINE = 350,
+     ENDWORD = 351,
+     ORDER = 352,
+     NAMEWORD = 353,
+     ASSERT_K = 354,
+     FORMAT = 355,
+     PUBLIC = 356,
+     DEFSYMEND = 357,
+     BASE = 358,
+     ALIAS = 359,
+     TRUNCATE = 360,
+     REL = 361,
+     INPUT_SCRIPT = 362,
+     INPUT_MRI_SCRIPT = 363,
+     INPUT_DEFSYM = 364,
+     CASE = 365,
+     EXTERN = 366,
+     START = 367,
+     VERS_TAG = 368,
+     VERS_IDENTIFIER = 369,
+     GLOBAL = 370,
+     LOCAL = 371,
+     VERSIONK = 372,
+     INPUT_VERSION_SCRIPT = 373,
+     KEEP = 374,
+     ONLY_IF_RO = 375,
+     ONLY_IF_RW = 376,
+     SPECIAL = 377,
+     EXCLUDE_FILE = 378,
+     CONSTANT = 379,
+     INPUT_DYNAMIC_LIST = 380
+   };
+#endif
+/* Tokens.  */
+#define INT 258
+#define NAME 259
+#define LNAME 260
+#define OREQ 261
+#define ANDEQ 262
+#define RSHIFTEQ 263
+#define LSHIFTEQ 264
+#define DIVEQ 265
+#define MULTEQ 266
+#define MINUSEQ 267
+#define PLUSEQ 268
+#define OROR 269
+#define ANDAND 270
+#define NE 271
+#define EQ 272
+#define GE 273
+#define LE 274
+#define RSHIFT 275
+#define LSHIFT 276
+#define UNARY 277
+#define END 278
+#define ALIGN_K 279
+#define BLOCK 280
+#define BIND 281
+#define QUAD 282
+#define SQUAD 283
+#define LONG 284
+#define SHORT 285
+#define BYTE 286
+#define SECTIONS 287
+#define PHDRS 288
+#define INSERT_K 289
+#define AFTER 290
+#define BEFORE 291
+#define DATA_SEGMENT_ALIGN 292
+#define DATA_SEGMENT_RELRO_END 293
+#define DATA_SEGMENT_END 294
+#define SORT_BY_NAME 295
+#define SORT_BY_ALIGNMENT 296
+#define SIZEOF_HEADERS 297
+#define OUTPUT_FORMAT 298
+#define FORCE_COMMON_ALLOCATION 299
+#define OUTPUT_ARCH 300
+#define INHIBIT_COMMON_ALLOCATION 301
+#define SEGMENT_START 302
+#define INCLUDE 303
+#define MEMORY 304
+#define REGION_ALIAS 305
+#define NOLOAD 306
+#define DSECT 307
+#define COPY 308
+#define INFO 309
+#define OVERLAY 310
+#define DEFINED 311
+#define TARGET_K 312
+#define SEARCH_DIR 313
+#define MAP 314
+#define ENTRY 315
+#define NEXT 316
+#define SIZEOF 317
+#define ALIGNOF 318
+#define ADDR 319
+#define LOADADDR 320
+#define MAX_K 321
+#define MIN_K 322
+#define CEILP2 323
+#define NACL_MASK 324
+#define STARTUP 325
+#define HLL 326
+#define SYSLIB 327
+#define FLOAT 328
+#define NOFLOAT 329
+#define NOCROSSREFS 330
+#define ORIGIN 331
+#define FILL 332
+#define LENGTH 333
+#define CREATE_OBJECT_SYMBOLS 334
+#define INPUT 335
+#define GROUP 336
+#define OUTPUT 337
+#define CONSTRUCTORS 338
+#define ALIGNMOD 339
+#define AT 340
+#define SUBALIGN 341
+#define PROVIDE 342
+#define PROVIDE_HIDDEN 343
+#define AS_NEEDED 344
+#define CHIP 345
+#define LIST 346
+#define SECT 347
+#define ABSOLUTE 348
+#define LOAD 349
+#define NEWLINE 350
+#define ENDWORD 351
+#define ORDER 352
+#define NAMEWORD 353
+#define ASSERT_K 354
+#define FORMAT 355
+#define PUBLIC 356
+#define DEFSYMEND 357
+#define BASE 358
+#define ALIAS 359
+#define TRUNCATE 360
+#define REL 361
+#define INPUT_SCRIPT 362
+#define INPUT_MRI_SCRIPT 363
+#define INPUT_DEFSYM 364
+#define CASE 365
+#define EXTERN 366
+#define START 367
+#define VERS_TAG 368
+#define VERS_IDENTIFIER 369
+#define GLOBAL 370
+#define LOCAL 371
+#define VERSIONK 372
+#define INPUT_VERSION_SCRIPT 373
+#define KEEP 374
+#define ONLY_IF_RO 375
+#define ONLY_IF_RW 376
+#define SPECIAL 377
+#define EXCLUDE_FILE 378
+#define CONSTANT 379
+#define INPUT_DYNAMIC_LIST 380
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 61 "ldgram.y"
+
+  bfd_vma integer;
+  struct big_int
+    {
+      bfd_vma integer;
+      char *str;
+    } bigint;
+  fill_type *fill;
+  char *name;
+  const char *cname;
+  struct wildcard_spec wildcard;
+  struct wildcard_list *wildcard_list;
+  struct name_list *name_list;
+  int token;
+  union etree_union *etree;
+  struct phdr_info
+    {
+      bfd_boolean filehdr;
+      bfd_boolean phdrs;
+      union etree_union *at;
+      union etree_union *flags;
+    } phdr;
+  struct lang_nocrossref *nocrossref;
+  struct lang_output_section_phdr_list *section_phdr;
+  struct bfd_elf_version_deps *deflist;
+  struct bfd_elf_version_expr *versyms;
+  struct bfd_elf_version_tree *versnode;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 333 "ldgram.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
diff -uNr binutils-2.19.51.20090622.orig/ld/ldlex.c binutils-2.19.51.20090622/ld/ldlex.c
--- binutils-2.19.51.20090622.orig/ld/ldlex.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.19.51.20090622/ld/ldlex.c	2009-06-28 17:16:42.000000000 +0200
@@ -0,0 +1,4307 @@
+
+#line 3 "ldlex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 192
+#define YY_END_OF_BUFFER 193
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[1617] =
+    {   0,
+        0,    0,  172,  172,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,  193,  192,
+      190,  175,  174,   32,  190,  172,   38,   29,   44,   43,
+       34,   35,   28,   36,  172,   37,    8,    8,   45,   46,
+       39,   40,   27,   33,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,   10,    9,  172,  117,  115,  172,
+       42,   30,   41,   31,  191,  175,   32,  191,  170,   38,
+       29,   44,   43,   34,   35,   28,   36,  170,   37,    8,
+        8,   45,   46,   39,   40,   27,   33,  170,  170,  170,
+
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,   10,    9,  170,  170,   42,   30,   41,   31,
+      168,   36,  168,   37,    8,    8,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  117,  115,  168,
+       31,    4,    3,    2,    4,    5,  129,  128,  167,   34,
+       35,   28,   36,  167,   37,    8,    8,   45,   46,   40,
+       33,  167,  167,  167,  167,  167,  167,  167,  167,  167,
+      167,  167,  167,   10,    9,  167,  167,  167,  167,  167,
+      167,  167,  167,  167,  167,  167,   31,  189,  187,  188,
+
+      190,  182,  181,  176,  183,  184,  180,  180,  180,  180,
+      185,  186,  175,   15,    0,  173,  172,    8,   26,   24,
+       22,   20,   21,    1,   23,    8,    8,  172,   18,   17,
+       14,   16,   19,  172,  172,  172,  172,  172,  121,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,   25,   13,  170,    6,
+       22,   20,   21,    0,    1,   23,    8,    0,    7,    7,
+
+        8,    7,   14,  170,    7,    7,    7,  170,  170,  121,
+        7,  170,  170,  170,    7,  170,  170,  170,    7,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,    7,  170,  168,
+        8,    0,   23,    8,    0,  168,  168,  168,  168,  168,
+      121,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+
+      168,    4,    4,  128,  128,  167,    6,  130,   22,  131,
+      167,    7,    7,    7,  167,  167,  167,    7,  167,    7,
+        7,  167,  167,  167,  167,  167,  167,  167,  167,    7,
+      167,  167,  167,    7,  167,    7,    7,  167,  167,  167,
+      167,  167,  167,  167,  167,  189,  188,  181,  180,    0,
+      180,  180,  180,   11,   12,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,   93,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,   72,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  118,  116,  172,    8,
+      171,    8,  170,    7,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,   61,   62,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,    8,  169,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,   93,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,   72,   61,  168,   62,  168,  168,
+
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  118,  116,  168,    4,    8,
+      167,  167,  167,  167,  167,  132,  167,  167,  167,  167,
+      167,  167,  167,  167,  167,  167,  167,  167,  167,  167,
+      167,  149,  167,  167,  167,  167,  167,  167,  167,  167,
+      167,  167,  180,  180,  180,  172,   58,  172,  172,  172,
+      172,  172,   52,  172,  100,  172,  109,  172,  172,  172,
+      172,  172,  172,  172,   89,  172,  172,  172,  172,  110,
+      172,  172,  172,  125,  172,  172,   98,  172,   68,  172,
+
+      172,  172,  172,  172,  172,  172,  172,  172,   96,  172,
+      172,  172,  172,  172,  172,  106,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  170,   58,  170,  170,  170,
+       52,  170,  170,  170,  109,  170,  170,  170,  170,  170,
+      170,  110,  125,  170,  170,  170,   68,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  168,
+       58,  168,  168,  168,  168,  168,   52,  168,  100,  168,
+      168,  109,  168,  168,  168,  168,  168,  168,  168,   89,
+      168,  168,  168,  168,  110,  168,  168,  168,  125,  168,
+      168,   98,  168,  168,   68,  168,  168,  168,  168,  168,
+
+      168,  168,  168,  168,   96,  168,  168,  168,  168,  168,
+      168,  106,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  167,  167,  167,  136,  144,  135,  167,  167,  146,
+      139,  142,  167,  167,  147,  167,  167,  167,  167,  167,
+      153,  161,  152,  167,  167,  164,  156,  159,  167,  167,
+      165,  167,  167,  180,  180,  180,  172,   87,   54,  172,
+      172,  172,   51,  172,  172,  172,  172,  108,   66,  172,
+      172,   95,  172,   78,  172,  172,   77,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  120,  172,
+      172,  172,  172,  172,   99,  172,  172,  172,   97,  172,
+
+      172,  172,  172,  172,  172,  172,  170,   54,  170,  170,
+       51,  170,  170,  170,  170,  108,  170,   78,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  168,   87,   54,  168,  168,  168,
+       51,  168,  168,  168,  168,  168,  108,   66,  168,  168,
+       95,  168,   78,  168,  168,   77,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  120,  168,
+      168,  168,  168,  168,   99,  168,  168,  168,   97,  168,
+      168,  168,  168,  168,  168,  168,  167,  137,  134,  167,
+      167,  146,  146,  141,  167,  145,  167,  167,  154,  151,
+
+      167,  167,  164,  164,  158,  167,  163,  167,  180,  180,
+      178,  172,  172,   65,  172,   88,  172,  172,  172,  172,
+      172,  172,   67,  172,  172,  172,   86,   53,  172,   47,
+      172,  172,  107,  172,   49,   76,  172,  172,  172,  172,
+      172,  172,   73,  172,  172,  172,  172,   94,   74,  172,
+      172,  172,  170,  170,   65,  170,   63,  170,  170,  170,
+      170,  170,   53,  170,  170,  170,  107,  170,   49,  170,
+      170,  170,   73,  170,  170,  170,  170,  168,  168,   65,
+      168,   88,   63,  168,  168,  168,  168,  168,  168,   67,
+      168,  168,  168,   86,   53,  168,   47,  168,  168,  168,
+
+      107,  168,   49,   76,  168,  168,  168,  168,  168,  168,
+       73,  168,  168,  168,  168,   94,   74,  168,  168,  168,
+      167,  167,   67,  143,  140,  167,  167,  167,  162,  160,
+      157,  167,  179,  177,  172,   60,  172,  172,  172,  172,
+      172,   80,  172,  172,  119,  172,  172,  172,  101,  172,
+      172,  103,  123,  172,  172,  172,  172,  172,  172,  114,
+       90,  172,   50,  172,  172,  170,   60,  170,  170,  170,
+       80,  170,  119,  170,  170,  170,  170,  111,  123,  170,
+      170,  114,  170,  170,  170,  168,   60,  168,  168,  168,
+      168,  168,   80,  168,  168,  119,  168,  168,  168,  168,
+
+      101,  168,  168,  103,  123,  168,  168,  168,  168,  168,
+      168,  114,   90,  168,   50,  168,  168,  167,  167,  167,
+      167,  167,  167,  148,  172,  127,  172,  172,  172,  172,
+      172,  172,   59,  172,  172,  172,  172,  172,  172,  172,
+       85,  172,  172,  172,  122,  166,  172,  148,  170,  127,
+      170,  170,   59,  170,  170,  170,  170,  170,  170,  122,
+      166,  170,  148,  168,  127,  168,  168,  168,  168,  168,
+      168,   59,  168,  168,  168,  168,  168,  168,  168,  168,
+       85,  168,  168,  168,  122,  166,  168,  148,  133,  138,
+      166,  150,  155,   79,  172,  172,  172,  172,  172,  172,
+
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,   79,  170,  170,   64,  170,  170,  170,  170,
+      170,  170,   79,  168,  168,  168,  168,  168,  168,   64,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  172,  172,  172,  172,  172,  172,  172,  112,
+      113,  172,  172,  172,  172,   75,  172,  172,  172,  172,
+      172,  170,  170,  170,  112,  113,  170,  170,  170,  170,
+      168,  168,  168,  168,  168,  168,  168,  112,  113,  168,
+      168,  168,  168,   75,  168,  168,  168,  168,  168,  172,
+      172,  172,  172,  172,  172,  102,   92,  172,  172,  172,
+
+      172,  172,  172,  172,  172,  170,  170,  102,  170,  170,
+      170,  170,  168,  168,  168,  168,  168,  168,  102,   92,
+      168,  168,  168,  168,  168,  168,  168,  168,   82,  172,
+      172,  126,  172,  172,  172,  172,   48,  172,  172,  172,
+      104,  172,  170,  126,  170,  170,  170,  170,   82,  168,
+      168,  126,  168,  168,  168,  168,   48,  168,  168,  168,
+      104,  168,  172,  172,  172,  172,   91,  172,   71,  172,
+      172,  172,  170,  170,   71,  170,  170,  168,  168,  168,
+      168,   91,  168,   71,  168,  168,  168,  172,  172,  172,
+      172,  172,  172,  124,   70,  172,   69,  170,  170,  170,
+
+      124,   70,   69,  168,  168,  168,  168,  168,  168,  124,
+       70,  168,   69,  172,  172,  172,  172,  172,  172,  172,
+      170,  170,  170,  168,  168,  168,  168,  168,  168,  168,
+      172,  172,   57,  172,  172,  172,  172,  170,   57,  170,
+      168,  168,   57,  168,  168,  168,  168,  172,  172,  172,
+      172,  172,  105,  170,  170,  168,  168,  168,  168,  168,
+      105,  172,   55,  172,  172,  172,   55,  170,  168,   55,
+      168,  168,  168,  172,  172,  172,  172,  170,  168,  168,
+      168,  168,  172,  172,  172,  172,  170,  168,  168,  168,
+      168,   81,  172,  172,  172,  170,   81,  168,  168,  168,
+
+       56,  172,  172,   56,   56,  168,  168,   83,  172,   83,
+      168,  172,  168,   84,   84,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    7,    8,    9,    1,   10,
+       11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
+       19,   19,   19,   19,   19,   19,   19,   21,   22,   23,
+       24,   25,   26,    1,   27,   28,   29,   30,   31,   32,
+       33,   34,   35,   36,   37,   38,   39,   40,   41,   42,
+       43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+       53,   54,   55,   56,   57,    1,   58,   59,   60,   61,
+
+       62,   63,   64,   65,   66,   16,   67,   68,   69,   70,
+       71,   72,   16,   73,   74,   75,   76,   16,   16,   77,
+       16,   78,   79,   80,   81,   82,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[83] =
+    {   0,
+        1,    1,    2,    3,    1,    1,    4,    1,    1,    1,
+        1,    5,    6,    7,    8,    9,   10,   11,   11,   11,
+        8,    1,    1,    7,    1,    5,   11,   11,   11,   11,
+       11,   11,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    8,    4,    8,    3,    9,   11,   11,   11,
+       11,   11,   11,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    1,    1,
+        1,   10
+    } ;
+
+static yyconst flex_int16_t yy_base[1641] =
+    {   0,
+        0,    0,    0,    0,   82,    0,  164,    0,  246,  327,
+      408,    0,  275,  277,  490,  572,  654,  736, 2610, 2611,
+     2611, 2607, 2611, 2584, 2602,  801, 2611,  264, 2611, 2611,
+     2582, 2581,    0, 2580,    0,  250,  581,  499,    0, 2611,
+      252, 2579,  260,    0,  259,  255,  254,  269,  263,  274,
+     2558, 2563, 2560, 2568,  276,  289,  277,  315,  277, 2551,
+     2566,  326, 2569, 2564,    0,    0, 2535, 2531, 2519, 2525,
+     2611,  239, 2611,    0, 2611, 2588, 2565, 2583,  847, 2611,
+      334, 2611, 2611, 2563, 2562, 2611,  298,    0,  352,  893,
+      294, 2611, 2611,  300, 2561,  350, 2611,  953,  351,  357,
+
+      494,  503,  576, 2540, 2543, 2551,  353,  343,  496,  486,
+     2537,  516, 2611, 2611,  652, 2514, 2611,  482, 2611,    0,
+     1013,  496,    0,  380,  745,  757,  655,  572,  511,  534,
+      350,  519, 2535, 2540, 2537, 2545,  360,  578,  588,  590,
+      568, 2528, 2543,  661, 2546, 2541, 2512, 2508, 2496, 2502,
+        0, 1059, 2611, 2611,    0, 2611, 2611, 2564, 1105, 2542,
+     2541, 2611, 2540,    0, 2539,    0,  479, 2611,    0, 2538,
+     2611, 1151,  605,  608,  611,  677,  653,  358, 2534, 2516,
+     2512,  504, 2514, 2611, 2611,  661,  685,  734,  765,  681,
+      545, 2499, 2483, 2479,  704, 2481,    0, 2551, 2611,    0,
+
+     2540, 2611,    0, 2611, 2611, 2611, 2530,  567,  620,  546,
+     2611, 2611, 2548, 2611, 2544, 2611,    0, 1211, 2611, 2611,
+        0,    0,    0,    0,    0,  769,    0,  744, 2524, 2611,
+        0, 2611, 2523, 2501, 2515, 2498, 2508,  669,    0, 2510,
+     2501, 2499, 2493,  605, 2507, 2491, 2504, 2504, 2488,  640,
+     2495, 2491, 2487, 2489, 2491,  805, 2497, 2487,  740, 2484,
+     2486, 2474,  692, 2485, 2487, 2475, 2489, 2489, 2477, 2490,
+     2483,  741, 2474, 2462, 2469, 2481, 2464, 2483, 2481, 2463,
+     2463, 2462, 2431, 2434, 2439, 2424, 2611, 2611,    0, 1263,
+     2611, 2611, 2611,    0, 2611, 2611,  701,  864,    0, 2611,
+
+     2611,    0, 2611,  842,  929,  962,    0, 2466,  683,    0,
+      989, 2460, 2458, 1018,  729, 1009, 1064, 2467, 2468, 2455,
+      773, 2464, 2454, 2466, 2442, 2451, 2461, 2439,  632, 2450,
+     2452, 2455, 2444, 2451, 2431, 2451, 2453, 1021, 2402,    0,
+     1315,    0,    0,  878,    0, 2434, 2448, 2431, 2441,  728,
+        0, 2443, 2434, 2432, 2426, 2436,  767, 2439, 2423, 2436,
+     2436, 2420,  702, 2427, 2423, 2419, 2421, 2423,  811, 2429,
+     2419,  770,  799, 2419, 2417, 2427, 2405,  819, 2416, 2418,
+     2406, 2420, 2420, 2408, 2421, 2414,  825, 2405, 2393, 2400,
+     2412, 2395, 2414, 2412, 2394, 2394, 2393, 2362, 2365, 2370,
+
+     2355,    0, 1367, 2429, 2611,    0, 1419,    0,    0,    0,
+      763,  857,  843,    0, 2396,  890,  891, 2395, 2399, 2382,
+     2383, 2381, 2398, 2385, 2393, 2394, 2392, 2393, 2372,  866,
+     2352,  948,  951, 2351, 2355, 2340, 2341, 2339, 2354, 2342,
+     2349, 2350, 2348, 2349, 2330, 2403,    0,    0, 2383, 2382,
+      711,  802,  878, 2611, 2611, 2361, 2357, 2369, 2366, 2367,
+     2357, 2355, 2365, 2365, 2362, 2347, 2340, 2363, 2362, 2353,
+     2358, 2342, 2347, 2353, 2345, 2355, 2352, 2333,    0, 2341,
+     2337, 2342, 2329, 2344, 2332, 2340, 2342, 2338,    0, 2329,
+     2323, 2324, 2329, 2325, 2314, 2331, 2321, 2318, 2317, 2312,
+
+     2329, 2323, 2313, 2310, 2316, 2310, 2322, 2306, 2322, 2323,
+     2305, 2321, 2309, 2313, 2300, 2273,    0,    0, 2281,    0,
+        0,  926, 2301, 1055, 2308, 2309, 2299, 2308, 2308, 2298,
+     2290, 2283, 2306, 1110, 2303, 2293, 2283, 2291, 2287, 2285,
+     2293, 2295,    0,    0, 2286, 2277, 2278, 2280, 2269, 2286,
+     2274, 2269, 2277, 2284, 2285, 2286, 2241, 2249,    0,    0,
+     2269, 2265, 2277, 2274, 2275, 2265, 2263, 2273, 2273, 2270,
+     2262, 2254, 2247, 2270, 2269, 2260, 2265, 2249, 2254, 2260,
+     2252, 2262, 2259, 2240,    0, 2248, 2244, 2249, 2236, 2251,
+     2239, 2247, 2249, 2245,    0,    0, 2236,    0, 2238, 2229,
+
+     2230, 2235, 2231, 2220, 2237, 2227, 2224, 2223, 2218, 2235,
+     2229, 2219, 2216, 2222, 2216, 2228, 2212, 2228, 2229, 2211,
+     2227, 2215, 2219, 2206, 2179,    0,    0, 2187,    0,    0,
+     2207,  859, 2216, 2215, 2203,    0, 2213, 2204, 2196, 2211,
+     2209, 2208, 2200, 2191, 2192, 2195, 2163,  884, 2171, 2170,
+     2159,    0, 2168, 2160, 2153, 2166, 2164, 2163, 2156, 2148,
+     2149, 2151,  663,  834,  769, 2182,    0, 2175, 2178, 2173,
+     2185, 2171,    0, 2177,    0, 2167,    0, 2166, 2154, 2170,
+     2163, 2157, 2160, 2162,    0, 2159, 2173, 2161, 2155,    0,
+     2173, 2154, 2155,    0, 2152, 2170,    0, 2152,    0, 2154,
+
+     2153, 2166, 2135, 2156, 2143, 2151, 2143, 2152,    0, 2145,
+     2156, 2149, 2152, 2136, 2140, 2123, 2144, 2148, 2131, 2138,
+     2140, 2143, 2138, 2104, 2100, 2132,    0, 2129, 2124, 2136,
+        0, 2129, 2123, 2118,    0, 2106, 2122, 2115, 2113, 2117,
+     2111,    0,    0, 2111, 2129, 2098,    0, 2113, 2126, 2095,
+     2116, 2112, 2114, 2117, 2106, 2111, 2107, 2076, 2072, 2104,
+        0, 2097, 2100, 2095, 2107, 2093,    0, 2099,    0, 2093,
+     2088,    0, 2078, 2056, 2062, 2045, 2032, 2030, 2031,    0,
+     2026, 2038, 2026, 2016,    0, 2024, 1995, 1986,    0, 1978,
+     1995,    0, 1962, 1948,    0, 1963, 1962, 1968, 1932,  247,
+
+      263,  327,  360,  462,    0,  487,  530,  573,  593,  594,
+      625,  649,  675,  795,  798,  808,  833,  838,  854,  822,
+      820,  862,  871,  886,    0,    0,    0,  893,  912, 1488,
+        0,    0,  900,  911,    0,  903,  921,  893,  892,  898,
+        0,    0,    0,  896,  919, 1569,    0,    0,  905,  922,
+        0,  921,  937,  984,  980, 1000,  955,    0,  963,  960,
+      978,  979,    0, 1025,  989,  978,  995,    0,    0,  998,
+      989,    0,  979,    0, 1020, 1023,    0, 1014, 1027, 1032,
+     1014, 1025, 1053, 1051, 1047, 1044, 1051, 1071,    0, 1073,
+     1064, 1071, 1065, 1067,    0, 1076, 1083, 1085,    0, 1066,
+
+     1079, 1087, 1070, 1085, 1051, 1065, 1082, 1089, 1085, 1108,
+        0, 1121, 1115, 1098, 1113,    0, 1116,    0, 1117, 1115,
+     1120, 1112, 1107, 1123, 1119, 1117, 1131, 1129, 1120, 1129,
+     1135, 1137, 1097, 1111, 1128,    0, 1135, 1131, 1153, 1155,
+        0, 1167, 1161, 1159, 1146, 1162,    0,    0, 1164, 1155,
+        0, 1139,    0, 1167, 1163,    0, 1153, 1166, 1172, 1152,
+     1165, 1161, 1180, 1178, 1180, 1177, 1172, 1192,    0, 1190,
+     1181, 1189, 1183, 1185,    0, 1194, 1199, 1205,    0, 1186,
+     1199, 1207, 1190, 1196, 1168, 1182, 1199,    0, 1208, 1209,
+     1205,    0, 1650,    0, 1223,    0, 1226, 1178,    0, 1186,
+
+     1186, 1182,    0, 1731,    0, 1198,    0, 1201, 1239, 1240,
+     1241, 1217, 1232,    0, 1235,    0, 1226, 1220, 1211, 1244,
+     1246, 1246,    0, 1250, 1253, 1239,    0,    0, 1256,    0,
+     1242, 1242,    0, 1257,    0, 1239, 1246, 1267, 1242, 1244,
+     1263, 1258, 1248, 1255, 1269, 1268, 1278,    0,    0, 1272,
+     1238, 1257, 1269, 1284,    0, 1287,    0, 1278, 1288, 1290,
+     1296, 1297,    0, 1299, 1304, 1291,    0, 1305,    0, 1287,
+     1308, 1294, 1284, 1310, 1316, 1275, 1294, 1307, 1323,    0,
+     1326,    0,    0, 1317, 1311, 1302, 1329, 1331, 1331,    0,
+     1334, 1333, 1319,    0,    0, 1336,    0, 1340, 1323, 1323,
+
+        0, 1338,    0, 1314, 1321, 1348, 1323, 1324, 1343, 1342,
+     1332, 1339, 1353, 1350, 1360,    0,    0, 1360, 1326, 1345,
+     1357, 1364,    0,    0,    0, 1361, 1333, 1338,    0,    0,
+        0, 1335, 1390, 1391, 1382,    0, 1383, 1369, 1387, 1376,
+     1385,    0, 1362, 1379,    0, 1364, 1378, 1379,    0, 1367,
+     1408,    0, 1374, 1405, 1403, 1396, 1385, 1409, 1387,    0,
+        0, 1405,    0, 1390, 1388, 1423,    0, 1424, 1411, 1426,
+        0, 1403,    0, 1417, 1417, 1419, 1407,    0, 1408, 1409,
+     1433,    0, 1428, 1407, 1405, 1440,    0, 1441, 1427, 1445,
+     1434, 1443,    0, 1426, 1443,    0, 1428, 1443, 1446, 1451,
+
+        0, 1444, 1476,    0, 1447, 1478, 1476, 1462, 1452, 1481,
+     1459,    0,    0, 1477,    0, 1456, 1454, 1489, 1491, 1491,
+     1461, 1463, 1463,    0, 1496,    0, 1481, 1500, 1490, 1498,
+     1492, 1503,    0, 1502, 1490, 1491, 1495, 1503, 1500, 1504,
+        0, 1495, 1510, 1515,    0,    0, 1481,    0, 1515,    0,
+     1507, 1515,    0, 1511, 1518, 1506, 1517, 1507, 1522,    0,
+        0, 1492,    0, 1526,    0, 1511, 1530, 1520, 1528, 1522,
+     1533,    0, 1526, 1533, 1521, 1522, 1531, 1542, 1544, 1549,
+        0, 1540, 1555, 1560,    0,    0, 1526,    0,    0,    0,
+        0,    0,    0,    0, 1548, 1554, 1565, 1562, 1559, 1558,
+
+     1569, 1561, 1574, 1560, 1570, 1571, 1563, 1562, 1582, 1573,
+     1585, 1555,    0, 1583, 1580,    0, 1584, 1577, 1582, 1573,
+     1593, 1563,    0, 1581, 1587, 1593, 1592, 1589, 1588,    0,
+     1598, 1590, 1603, 1589, 1599, 1600, 1592, 1591, 1611, 1602,
+     1614, 1584, 1599, 1613, 1605, 1608, 1606, 1614, 1612,    0,
+        0, 1629, 1626, 1636, 1640,    0, 1641, 1639, 1635, 1632,
+     1616, 1638, 1641, 1635,    0,    0, 1651, 1655, 1653, 1623,
+     1641, 1655, 1647, 1650, 1648, 1651, 1646,    0,    0, 1658,
+     1654, 1664, 1668,    0, 1669, 1667, 1663, 1660, 1639, 1656,
+     1673, 1657, 1673, 1665, 1668,    0,    0, 1681, 1679, 1665,
+
+     1667, 1681, 1680, 1683, 1653, 1670, 1686,    0, 1688, 1675,
+     1689, 1659, 1677, 1694, 1678, 1694, 1686, 1688,    0,    0,
+     1701, 1704, 1693, 1700, 1715, 1714, 1717, 1687,    0, 1704,
+     1694,    0, 1695, 1717, 1713, 1729,    0, 1715, 1718, 1723,
+        0, 1691, 1708,    0, 1735, 1721, 1724, 1696,    0, 1724,
+     1714,    0, 1715, 1732, 1728, 1744,    0, 1730, 1733, 1738,
+        0, 1706, 1723, 1754, 1755, 1743,    0, 1744,    0, 1741,
+     1749, 1715, 1763, 1751,    0, 1747, 1719, 1738, 1769, 1770,
+     1759,    0, 1761,    0, 1757, 1764, 1730, 1760, 1768, 1768,
+     1778, 1776, 1758,    0,    0, 1785,    0, 1779, 1778, 1788,
+
+        0,    0,    0, 1775, 1783, 1782, 1792, 1786, 1768,    0,
+        0, 1795,    0, 1776, 1793, 1799, 1792, 1793, 1805, 1793,
+     1799, 1805, 1798, 1786, 1803, 1809, 1802, 1803, 1815, 1803,
+     1805, 1812,    0, 1802, 1806, 1810, 1803, 1817,    0, 1807,
+     1813, 1820,    0, 1810, 1814, 1818, 1811, 1830, 1819, 1819,
+     1832, 1824,    0, 1823, 1823, 1837, 1826, 1826, 1839, 1831,
+        0, 1829,    0, 1814, 1845, 1832,    0, 1817, 1834,    0,
+     1819, 1850, 1837, 1841, 1849, 1835, 1853, 1852, 1846, 1854,
+     1840, 1858, 1843, 1849, 1855, 1864, 1852, 1848, 1854, 1860,
+     1869,    0, 1867, 1857, 1853, 1870,    0, 1871, 1861, 1857,
+
+        0, 1864, 1870,    0,    0, 1866, 1872,    0, 1867,    0,
+     1868, 1870, 1871,    0,    0, 2611, 1911, 1922, 1933, 1944,
+     1955, 1966, 1974, 1982, 1990, 1998, 2009, 2017, 2028, 2039,
+     2050, 2053, 2062, 2070, 1976, 2078, 2089, 2100, 2111, 2122
+    } ;
+
+static yyconst flex_int16_t yy_def[1641] =
+    {   0,
+     1617, 1617, 1616,    3, 1616,    5, 1616,    7, 1618, 1618,
+     1616,   11, 1619, 1619, 1620, 1620, 1621, 1621, 1616, 1616,
+     1616, 1616, 1616, 1616, 1622, 1623, 1616, 1616, 1616, 1616,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1616,
+     1616, 1623, 1616, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1616, 1616, 1616, 1623, 1616, 1616, 1616, 1622, 1624, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1624, 1624, 1616,
+       90, 1616, 1616, 1616, 1616, 1616, 1616, 1624,   98,   98,
+
+       98,   98,   98, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1616, 1616,   98, 1624, 1616, 1616, 1616, 1624,
+     1625, 1616, 1625, 1625, 1616, 1616, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1626, 1616, 1616, 1626, 1616, 1616, 1627, 1628, 1629,
+     1616, 1616, 1616, 1628, 1628,   90,   90, 1616, 1630, 1616,
+     1616, 1628,  172,  172,  172,  172,  172, 1628, 1628, 1628,
+     1628, 1628, 1628, 1616, 1616,  172,  172,  172,  172,  172,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1616, 1616, 1631,
+
+     1616, 1616, 1632, 1616, 1616, 1616, 1633, 1633, 1633, 1633,
+     1616, 1616, 1616, 1616, 1622, 1616, 1623, 1623, 1616, 1616,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623,  218, 1616, 1616,
+     1623, 1616, 1616, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1616, 1616, 1624, 1624,
+     1616, 1616, 1616, 1634, 1616, 1616,   90,   90,  298, 1616,
+
+     1616, 1635, 1616,   98,   98,   98, 1624, 1624, 1624, 1624,
+       98, 1624, 1624,   98, 1624,   98,   98, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624,   98, 1624, 1625,
+     1625, 1636, 1625, 1616, 1635, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1626, 1626, 1627, 1616, 1628, 1628, 1629, 1629, 1630,
+      172,  172,  172, 1628, 1628,  172,  172, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,  172,
+     1628,  172,  172, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1616, 1631, 1632, 1633, 1616,
+     1633, 1633, 1633, 1616, 1616, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624,
+     1634, 1635, 1624,   98, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624,   98, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1625, 1636,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1626, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1633, 1633, 1633, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1637,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1638, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1633, 1633, 1633, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1628, 1628, 1628, 1628,
+     1628, 1639, 1637, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+
+     1628, 1628, 1640, 1638, 1628, 1628, 1628, 1628, 1633, 1633,
+     1633, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1633, 1633, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1628, 1628, 1628,
+     1628, 1628, 1628, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1628, 1628, 1628,
+     1628, 1628, 1628, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1624, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624,
+
+     1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623, 1623, 1623,
+     1623, 1623, 1623, 1624, 1624, 1625, 1625, 1625, 1625, 1625,
+     1625, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1625, 1625,
+     1625, 1625, 1625, 1623, 1623, 1623, 1623, 1624, 1625, 1625,
+     1625, 1625, 1623, 1623, 1623, 1623, 1624, 1625, 1625, 1625,
+     1625, 1623, 1623, 1623, 1623, 1624, 1625, 1625, 1625, 1625,
+
+     1623, 1623, 1623, 1624, 1625, 1625, 1625, 1623, 1623, 1625,
+     1625, 1623, 1625, 1623, 1625,    0, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616
+    } ;
+
+static yyconst flex_int16_t yy_nxt[2694] =
+    {   0,
+       21,   22,   23,   24,   25,   21,   26,   27,   28,   29,
+       30,   31,   32,   33,   34,   35,   36,   37,   38,   38,
+       39,   40,   41,   42,   43,   44,   45,   46,   47,   48,
+       49,   50,   51,   52,   53,   35,   54,   55,   56,   57,
+       58,   59,   60,   61,   62,   63,   35,   64,   35,   35,
+       35,   35,   65,   35,   66,   21,   35,   67,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   68,   35,   35,
+       69,   35,   35,   70,   35,   35,   35,   35,   71,   72,
+       73,   74,   75,   76,   23,   77,   78,   75,   79,   80,
+       81,   82,   83,   84,   85,   86,   87,   88,   89,   90,
+
+       91,   91,   92,   93,   94,   95,   96,   97,   98,   99,
+      100,  101,  102,  103,  104,   88,  105,   88,  106,  107,
+      108,  109,  110,  111,   88,   88,  112,   88,   88,   88,
+       88,   88,   88,   88,  113,   88,  114,   75,   88,  115,
+      103,  103,  103,  103,  103,   88,   88,   88,   88,   88,
+       88,   88,   88,   88,   88,  116,   88,   88,   88,   88,
+      117,  118,  119,  120,   75,   76,   23,   77,   78,   75,
+      121,   80,   81,   82,   83,   84,   85,   86,  122,  123,
+      124,  125,  126,  126,   92,   93,   94,   95,   96,   97,
+      127,  128,  129,  130,  131,  132,  133,  134,  135,  123,
+
+      136,  137,  138,  139,  140,  141,  142,  143,  144,  145,
+      123,  146,  123,  123,  123,  123,  113,  123,  114,   75,
+      123,  147,  123,  123,  123,  123,  123,  123,  123,  123,
+      123,  148,  123,  123,  149,  123,  123,  150,  123,  123,
+      123,  123,  117,  118,  119,  151,   75,   75,   20,   75,
+       75,   75,  152,   75,   75,   75,   75,   75,  153,   75,
+      154,  224,  287,  125,  126,  126,   75,   75,   75,  156,
+       75,   75,  219,  225,  229,  230,  198,  199,  198,  199,
+      200,  966,  200,  232,  233,  240,  234,  220,  235,  241,
+      236,  201,  242,  201,  244,  246,  237,  245,   75,  247,
+
+       75,   75,  249,  238,  239,  243,  258,  262,  251,  967,
+      268,  252,  250,  248,  253,  260,  259,  263,  288,  261,
+      269,  293,  229,  230,   75,   75,   75,   75,   75,   20,
+       75,   75,   75,  152,   75,   75,   75,   75,   75,  153,
+       75,  154,  219,  300,  125,  126,  126,   75,   75,   75,
+      156,   75,   75,  202,  264,  202,  272,  220,  265,  273,
+      274,  266,  267,  295,  968,  294,  275,  276,  277,  325,
+      300,  278,  279,  232,  233,  296,  280,  326,  311,   75,
+      311,   75,   75,  323,  311,  312,  311,  314,  313,  362,
+      371,  295,  422,  324,  289,  289,  289,  315,  423,  363,
+
+      372,  289,  289,  343,  969,   75,   75,   75,   21,   22,
+      157,   24,   21,  158,  159,   27,   28,   29,   30,  160,
+      161,  162,  163,  164,  165,  166,  167,  167,  168,  169,
+       41,  170,   43,  171,  172,  173,  174,  175,  176,  177,
+      164,  164,  164,  164,  164,  178,  164,  179,  180,  181,
+      164,  164,  182,  183,  164,  164,  164,  164,  164,  164,
+      184,  164,  185,   21,  164,  186,  187,  188,  175,  189,
+      190,  164,  164,  164,  164,  191,  164,  192,  193,  194,
+      164,  195,  196,  164,  164,  164,   71,   72,   73,  197,
+       21,  198,  199,   21,   21,  200,  970,   21,   21,   21,
+
+       21,   21,   21,  204,   21,  287,  201,   21,   21,   21,
+      204,  204,   21,   21,   21,   21,  226,  226,  226,  293,
+      316,  311,  327,  311,  317,  330,  328,  971,  300,  331,
+      311,  289,  311,  332,  427,  227,  329,  227,  318,  289,
+      289,  356,   21,   21,   21,   21,  334,  289,  289,  428,
+      335,  357,  319,  364,  358,  300,  365,  336,  972,  366,
+      359,  288,  337,  342,  360,  227,  450,  227,  205,   21,
+      206,   21,   21,  198,  199,   21,   21,  200,  361,   21,
+       21,   21,   21,   21,   21,  204,   21,  450,  201,   21,
+       21,   21,  204,  204,   21,   21,   21,   21,  226,  226,
+
+      226,  383,  352,  311,  373,  311,  353,  973,  374,  354,
+      438,  384,  375,  289,  376,  439,  453,  227,  377,  227,
+      289,  289,  355,  974,   21,   21,   21,   21,  378,  379,
+      228,  416,  413,  380,  417,  413,  381,  382,  413,  975,
+      450,  418,  406,  451,  466,  406,  467,  227,  406,  227,
+      205,   21,  206,   21,   21,  198,  199,  228,   25,  200,
+      547,   21,   21,   21,   21,  976,   21,  204,  473,  548,
+      201,   21,   21,   21,  204,  204,   21,   21,   21,  311,
+      413,  311,  346,  450,  347,  474,  348,  452,  413,  289,
+      406,  387,  349,  421,  388,  389,  289,  289,  406,  350,
+
+      351,  390,  391,  392,  413,  977,  393,  394,  413,  978,
+      338,  395,  413,  460,  406,  208,  419,  209,  406,  430,
+      492,  210,  406,  493,  854,  461,  420,  526,  431,  494,
+      579,  450,  211,   21,  212,   21,   21,  198,  199,  527,
+       25,  200,  432,   21,   21,   21,   21,  580,   21,  204,
+      300,  437,  201,   21,   21,   21,  204,  204,   21,   21,
+       21,  413,  344,  344,  344,  443,  487,  503,  531,  504,
+      532,  406,  565,  505,  344,  344,  344,  300,  444,  488,
+      217,  301,  217,  301,  566,  663,  226,  226,  226,  450,
+      413,  433,  413,  301,  345,  301,  593,  208,  434,  209,
+
+      406,  538,  406,  210,  539,  227,  572,  227,  573,  594,
+      217,  301,  217,  301,  211,   21,  212,   21,  218,  218,
+      218,  345,  450,  301,  979,  301,  856,  218,  218,  218,
+      218,  218,  218,  480,  435,  227,  481,  227,  482,  586,
+      595,  436,  587,  980,  588,  981,  483,  601,  596,  484,
+      602,  612,  589,  613,  450,  590,  603,  614,  218,  218,
+      218,  218,  218,  218,  290,  290,  290,  982,  983,  311,
+      413,  311,  664,  290,  290,  290,  290,  290,  290,  289,
+      406,  298,  298,  298,  413,  823,  289,  289,  984,  985,
+      986,  824,  855,  413,  406,  344,  344,  344,  450,  987,
+
+     1616,  631, 1616,  406,  290,  290,  290,  290,  290,  290,
+      297,  297,  297,  300,  301,  988,  301,  413,  413,  298,
+      299,  298,  299,  298,  298,  989,  300,  406,  406,  301,
+     1616,  301, 1616,  300,  633,  634,  990,  665,  991,  647,
+      300,  839,  302,  994,  301,  995,  301,  840,  996,  997,
+      298,  299,  298,  299,  298,  298,  311,  300,  311,  301,
+      998,  301,  301,  300,  301,  999,  289, 1000, 1001,  302,
+      304,  304,  304,  523,  289,  413, 1002, 1005,  413,  304,
+      305,  304,  306,  304,  304,  406,  307, 1006,  406,  311,
+      308,  524,  301,  307,  301, 1007, 1008,  309,  310,  289,
+
+      450, 1012,  307, 1013,  450, 1014,  289,  289, 1015, 1016,
+      304,  311,  304,  311,  304,  304,  311,  307,  311, 1019,
+      450,  649, 1020,  307,  650, 1021,  289, 1022, 1023,  307,
+      341,  341,  341,  289,  289, 1024,  311, 1010,  311,  341,
+      341,  341,  341,  341,  341,  311,  289,  311,  311, 1025,
+      311, 1017,  530,  289,  533,  289, 1009, 1026,  289, 1027,
+     1028, 1029,  289,  289, 1030,  289,  289, 1011, 1018, 1031,
+      341,  341,  341,  341,  341,  341,  403,  403,  403, 1032,
+     1033, 1034,  311, 1035,  311,  403,  403,  403,  403,  403,
+      403,  311,  289,  311,  557,  534, 1036, 1037,  727,  289,
+
+      289,  289, 1038, 1039, 1040, 1041, 1042, 1043,  289,  289,
+     1044, 1045, 1046, 1047, 1048, 1049,  403,  403,  403,  403,
+      403,  403,  407,  407,  407, 1050, 1051, 1052, 1053, 1054,
+     1055,  407,  407,  407,  407,  407,  407,  311, 1056,  311,
+     1057, 1058, 1059, 1060,  737, 1061, 1062,  289, 1063, 1064,
+     1065, 1066, 1067, 1068,  289,  289, 1069, 1070, 1071, 1072,
+     1073, 1074,  407,  407,  407,  407,  407,  407,  411,  411,
+      411, 1075, 1076, 1077, 1078, 1079, 1080,  411,  412,  411,
+      413,  411,  411, 1081,  414, 1082, 1083, 1084,  415, 1086,
+     1087,  414, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095,
+
+      414, 1096, 1097, 1098, 1085, 1099, 1100, 1101,  411,  413,
+      411,  413,  411,  411, 1102,  414, 1103, 1104, 1105, 1106,
+     1107,  414, 1108, 1109, 1110, 1111, 1112,  414,  218,  218,
+      218, 1113, 1114, 1115, 1116, 1117, 1118,  218,  218,  218,
+      218,  218,  218, 1119, 1120, 1121, 1122,  227, 1123,  227,
+     1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132,  450,
+      450,  450, 1135, 1136, 1137, 1138, 1139, 1140,  218,  218,
+      218,  218,  218,  218, 1141, 1142, 1143,  227, 1144,  227,
+      290,  290,  290, 1145, 1146, 1147, 1148, 1149, 1150,  290,
+      290,  290,  290,  290,  290, 1151, 1152, 1153, 1154,  520,
+
+     1155,  520, 1156, 1157, 1158, 1159, 1160, 1134, 1133, 1161,
+     1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171,
+      290,  290,  290,  290,  290,  290, 1172, 1173, 1174,  520,
+     1175,  520,  341,  341,  341, 1176, 1177, 1178, 1179, 1180,
+     1181,  341,  341,  341,  341,  341,  341, 1182, 1183, 1184,
+     1185,  559, 1186,  559, 1187, 1188, 1189, 1190, 1191, 1192,
+     1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202,
+     1203, 1204,  341,  341,  341,  341,  341,  341, 1205, 1206,
+     1207,  559, 1208,  559,  403,  403,  403, 1209, 1210, 1211,
+     1212, 1213, 1214,  403,  403,  403,  403,  403,  403, 1215,
+
+     1216, 1217, 1218,  629, 1219,  629, 1220, 1221, 1222, 1223,
+      450,  450, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231,
+     1232, 1233, 1234, 1235,  403,  403,  403,  403,  403,  403,
+     1238, 1239, 1240,  629, 1236,  629,  407,  407,  407, 1237,
+     1241, 1242, 1243, 1244, 1245,  407,  407,  407,  407,  407,
+      407, 1246, 1247, 1248, 1249,  630, 1250,  630, 1251, 1252,
+     1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262,
+     1263, 1264, 1265, 1266, 1267, 1268,  407,  407,  407,  407,
+      407,  407, 1269, 1270, 1271,  630, 1272,  630,  992,  992,
+     1273,  992,  992,  992, 1274,  992,  992,  992,  992,  992,
+
+     1275,  992, 1276, 1278, 1279, 1280, 1281, 1277, 1282,  992,
+      992,  992,  992,  992, 1283, 1284, 1285, 1286, 1287, 1288,
+     1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298,
+     1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308,
+     1309, 1310, 1312,  992, 1313, 1314, 1315, 1316, 1317, 1318,
+     1319, 1320, 1321, 1322, 1311, 1323, 1324, 1325, 1326, 1327,
+     1328, 1329, 1330, 1331, 1332, 1333,  992,  992,  992, 1003,
+     1003, 1334, 1003, 1003, 1003, 1335, 1003, 1003, 1003, 1003,
+     1003, 1336, 1003, 1337, 1338, 1339, 1340, 1342, 1343, 1344,
+     1003, 1003, 1003, 1003, 1003, 1345, 1346, 1347, 1348, 1341,
+
+     1349, 1350, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1351,
+     1359, 1360, 1361, 1362, 1363, 1364, 1367, 1365, 1368, 1369,
+     1370, 1371, 1372, 1373, 1003, 1366, 1374, 1375, 1376, 1377,
+     1378, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1379, 1387,
+     1388, 1389, 1390, 1391, 1392, 1393, 1394, 1003, 1003, 1003,
+      992,  992, 1395,  992,  992,  992, 1396,  992,  992,  992,
+      992,  992, 1397,  992, 1398, 1399, 1400, 1401, 1402, 1403,
+     1404,  992,  992,  992,  992,  992, 1405, 1406, 1407, 1408,
+     1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418,
+     1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428,
+
+     1429, 1430, 1431, 1432, 1433,  992, 1434, 1435, 1436, 1437,
+     1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447,
+     1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455,  992,  992,
+      992, 1003, 1003, 1456, 1003, 1003, 1003, 1457, 1003, 1003,
+     1003, 1003, 1003, 1458, 1003, 1459, 1460, 1461, 1462, 1463,
+     1464, 1465, 1003, 1003, 1003, 1003, 1003, 1466, 1467, 1468,
+     1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478,
+     1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488,
+     1489, 1492, 1493, 1494, 1490, 1495, 1003, 1496, 1497, 1498,
+     1501, 1502, 1503, 1499, 1504, 1505, 1508, 1491, 1509, 1506,
+
+     1510, 1511, 1512, 1513, 1514, 1515, 1500, 1516, 1517, 1003,
+     1003, 1003, 1507, 1518, 1519, 1520, 1521, 1522, 1523, 1524,
+     1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534,
+     1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544,
+     1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554,
+     1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564,
+     1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574,
+     1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584,
+     1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594,
+     1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604,
+
+     1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614,
+     1615,   20,   20,   20,   20,   20,   20,   20,   20,   20,
+       20,   20,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,   21,   21,   21,   21,   21,   21,   21,
+       21,   21,   21,   21,  203,  203,  203,  203,  203,  203,
+      203,  203,  203,  203,  203,  207,  207,  207,  207,  207,
+      207,  207,  207,  207,  207,  207,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  217,  217,  217,
+      217,  217,  217,  217,  217,  289,  522,  289,  965,  289,
+      289,  289,  289,  340,  964,  340,  340,  340,  340,  340,
+
+      340,  402,  963,  962,  961,  960,  402,  402,  402,  404,
+      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
+      406,  959,  406,  958,  406,  406,  406,  406,  408,  957,
+      408,  408,  408,  408,  408,  408,  408,  408,  408,  410,
+      956,  410,  410,  410,  410,  410,  410,  410,  410,  410,
+      447,  955,  447,  447,  447,  447,  447,  447,  447,  447,
+      447,  448,  954,  448,  449,  449,  449,  953,  952,  449,
+      449,  951,  449,  521,  950,  521,  949,  521,  521,  521,
+      521,  560,  948,  560,  560,  560,  560,  560,  560,  993,
+      947,  993,  993,  993,  993,  993,  993,  993,  993,  993,
+
+     1004,  946, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004,
+     1004,  992,  945,  992,  992,  992,  992,  992,  992,  992,
+      992,  992, 1003,  944, 1003, 1003, 1003, 1003, 1003, 1003,
+     1003, 1003, 1003,  943,  942,  941,  940,  939,  938,  937,
+      936,  935,  934,  933,  932,  931,  930,  929,  928,  927,
+      926,  925,  924,  923,  922,  921,  920,  919,  918,  917,
+      916,  915,  914,  913,  912,  911,  910,  909,  908,  907,
+      906,  905,  904,  903,  902,  901,  900,  899,  898,  897,
+      896,  895,  894,  893,  892,  891,  890,  889,  888,  887,
+      886,  885,  884,  883,  882,  881,  880,  879,  878,  877,
+
+      876,  875,  874,  873,  872,  871,  870,  869,  868,  867,
+      866,  865,  864,  863,  862,  861,  860,  859,  858,  857,
+      853,  852,  851,  850,  849,  848,  847,  846,  845,  844,
+      843,  842,  841,  838,  837,  836,  835,  834,  833,  832,
+      831,  830,  829,  828,  827,  826,  825,  822,  821,  820,
+      819,  818,  817,  816,  815,  814,  813,  812,  811,  810,
+      809,  808,  807,  806,  805,  804,  803,  802,  801,  800,
+      799,  798,  797,  796,  795,  794,  793,  792,  791,  790,
+      789,  788,  787,  786,  785,  784,  783,  782,  781,  780,
+      779,  778,  777,  776,  775,  774,  773,  772,  771,  770,
+
+      769,  768,  767,  766,  765,  764,  763,  762,  761,  760,
+      759,  758,  757,  756,  755,  754,  753,  752,  751,  750,
+      749,  748,  747,  746,  745,  744,  743,  742,  741,  740,
+      739,  738,  736,  735,  734,  733,  732,  731,  730,  729,
+      728,  726,  725,  724,  723,  722,  721,  720,  719,  718,
+      717,  716,  715,  714,  713,  712,  711,  710,  709,  708,
+      707,  706,  705,  704,  703,  702,  701,  700,  699,  698,
+      697,  696,  695,  694,  693,  692,  691,  690,  689,  688,
+      687,  686,  685,  684,  683,  682,  681,  680,  679,  678,
+      677,  676,  675,  674,  673,  672,  671,  670,  669,  668,
+
+      667,  666,  449,  450,  446,  662,  661,  660,  659,  658,
+      657,  656,  655,  654,  653,  652,  651,  648,  646,  645,
+      644,  643,  642,  641,  640,  639,  638,  637,  636,  635,
+      632,  405,  628,  627,  626,  625,  624,  623,  622,  621,
+      620,  619,  618,  617,  616,  615,  611,  610,  609,  608,
+      607,  606,  605,  604,  600,  599,  598,  597,  592,  591,
+      585,  584,  583,  582,  581,  578,  577,  576,  575,  574,
+      571,  570,  569,  568,  567,  564,  563,  562,  561,  558,
+      556,  555,  554,  553,  552,  551,  550,  549,  546,  545,
+      544,  543,  542,  541,  540,  537,  536,  535,  529,  528,
+
+      525,  519,  518,  517,  516,  515,  514,  513,  512,  511,
+      510,  509,  508,  507,  506,  502,  501,  500,  499,  498,
+      497,  496,  495,  491,  490,  489,  486,  485,  479,  478,
+      477,  476,  475,  472,  471,  470,  469,  468,  465,  464,
+      463,  462,  459,  458,  457,  456,  455,  454,  216,  213,
+      450,  295,  446,  445,  442,  441,  440,  429,  426,  425,
+      424,  303,  296,  293,  292,  409,  405,  401,  400,  399,
+      398,  397,  396,  386,  385,  370,  369,  368,  367,  339,
+      333,  322,  321,  320,  303,  292,  291,  216,  214,  213,
+      286,  285,  284,  283,  282,  281,  271,  270,  257,  256,
+
+      255,  254,  231,  223,  222,  221,  216,  214,  213, 1616,
+       19, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616
+
+    } ;
+
+static yyconst flex_int16_t yy_chk[2694] =
+    {   0,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,   36,   72,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,   28,   36,   41,   41,   13,   13,   14,   14,
+       13,  800,   14,   43,   43,   46,   45,   28,   45,   46,
+       45,   13,   46,   14,   47,   48,   45,   47,    9,   48,
+
+        9,    9,   49,   45,   45,   46,   55,   57,   50,  801,
+       59,   50,   49,   48,   50,   56,   55,   57,   72,   56,
+       59,   87,   94,   94,    9,    9,    9,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,   81,   91,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   13,   58,   14,   62,   81,   58,   62,
+       62,   58,   58,   89,  802,   87,   62,   62,   62,  108,
+       91,   62,   62,   96,   96,   89,   62,  108,   99,   10,
+       99,   10,   10,  107,  100,   99,  100,  100,   99,  131,
+      137,  124,  178,  107,  100,   99,   99,  100,  178,  131,
+
+      137,  100,  100,  124,  803,   10,   10,   10,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       15,   15,   15,   15,   15,   15,  804,   15,   15,   15,
+
+       15,   15,   15,   15,   15,  118,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   38,   38,   38,  122,
+      101,  101,  109,  101,  101,  110,  109,  806,  167,  110,
+      102,  101,  102,  110,  182,   38,  109,   38,  101,  101,
+      102,  129,   15,   15,   15,   15,  112,  102,  102,  182,
+      112,  129,  102,  132,  129,  167,  132,  112,  807,  132,
+      130,  118,  112,  122,  130,   38,  210,   38,   15,   15,
+       15,   15,   16,   16,   16,   16,   16,   16,  130,   16,
+       16,   16,   16,   16,   16,   16,   16,  208,   16,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   37,   37,
+
+       37,  141,  128,  103,  138,  103,  128,  808,  138,  128,
+      191,  141,  138,  103,  139,  191,  210,   37,  139,   37,
+      103,  103,  128,  809,   16,   16,   16,   16,  139,  140,
+       37,  173,  173,  140,  174,  174,  140,  140,  175,  810,
+      209,  174,  173,  208,  244,  174,  244,   37,  175,   37,
+       16,   16,   16,   16,   17,   17,   17,   37,   17,   17,
+      329,   17,   17,   17,   17,  811,   17,   17,  250,  329,
+       17,   17,   17,   17,   17,   17,   17,   17,   17,  115,
+      177,  115,  127,  663,  127,  250,  127,  209,  186,  115,
+      177,  144,  127,  177,  144,  144,  115,  115,  186,  127,
+
+      127,  144,  144,  144,  176,  812,  144,  144,  190,  813,
+      115,  144,  187,  238,  176,   17,  176,   17,  190,  186,
+      263,   17,  187,  263,  663,  238,  176,  309,  186,  263,
+      363,  451,   17,   17,   17,   17,   18,   18,   18,  309,
+       18,   18,  187,   18,   18,   18,   18,  363,   18,   18,
+      297,  190,   18,   18,   18,   18,   18,   18,   18,   18,
+       18,  188,  125,  125,  125,  195,  259,  272,  315,  272,
+      315,  188,  350,  272,  126,  126,  126,  297,  195,  259,
+      228,  125,  228,  125,  350,  451,  226,  226,  226,  665,
+      411,  188,  189,  126,  125,  126,  372,   18,  188,   18,
+
+      411,  321,  189,   18,  321,  226,  357,  226,  357,  372,
+      228,  125,  228,  125,   18,   18,   18,   18,   26,   26,
+       26,  125,  452,  126,  814,  126,  665,   26,   26,   26,
+       26,   26,   26,  256,  189,  226,  256,  226,  256,  369,
+      373,  189,  369,  815,  369,  816,  256,  378,  373,  256,
+      378,  387,  369,  387,  664,  369,  378,  387,   26,   26,
+       26,   26,   26,   26,   79,   79,   79,  817,  818,  304,
+      413,  304,  452,   79,   79,   79,   79,   79,   79,  304,
+      413,  298,  298,  298,  412,  632,  304,  304,  819,  820,
+      821,  632,  664,  430,  412,  344,  344,  344,  453,  822,
+
+      298,  412,  298,  430,   79,   79,   79,   79,   79,   79,
+       90,   90,   90,  298,  344,  823,  344,  416,  417,   90,
+       90,   90,   90,   90,   90,  824,   90,  416,  417,   90,
+      298,   90,  298,   90,  416,  417,  828,  453,  829,  430,
+      298,  648,   90,  833,  344,  834,  344,  648,  836,  837,
+       90,   90,   90,   90,   90,   90,  305,   90,  305,   90,
+      838,   90,  522,   90,  522,  839,  305,  840,  844,   90,
+       98,   98,   98,  305,  305,  432,  845,  849,  433,   98,
+       98,   98,   98,   98,   98,  432,   98,  850,  433,  306,
+       98,  306,  522,   98,  522,  852,  853,   98,   98,  306,
+
+      855,  857,   98,  859,  854,  860,  306,  306,  861,  862,
+       98,   98,   98,   98,   98,   98,  311,   98,  311,  865,
+      856,  432,  866,   98,  433,  867,  311,  870,  871,   98,
+      121,  121,  121,  311,  311,  873,  316,  855,  316,  121,
+      121,  121,  121,  121,  121,  314,  316,  314,  338,  875,
+      338,  864,  314,  316,  316,  314,  854,  876,  338,  878,
+      879,  880,  314,  314,  881,  338,  338,  856,  864,  882,
+      121,  121,  121,  121,  121,  121,  152,  152,  152,  883,
+      884,  885,  524,  886,  524,  152,  152,  152,  152,  152,
+      152,  317,  524,  317,  338,  317,  887,  888,  524,  524,
+
+      524,  317,  890,  891,  892,  893,  894,  896,  317,  317,
+      897,  898,  900,  901,  902,  903,  152,  152,  152,  152,
+      152,  152,  159,  159,  159,  904,  905,  906,  907,  908,
+      909,  159,  159,  159,  159,  159,  159,  534,  910,  534,
+      912,  913,  914,  915,  534,  917,  919,  534,  920,  921,
+      922,  923,  924,  925,  534,  534,  926,  927,  928,  929,
+      930,  931,  159,  159,  159,  159,  159,  159,  172,  172,
+      172,  932,  933,  934,  935,  937,  938,  172,  172,  172,
+      172,  172,  172,  939,  172,  940,  942,  943,  172,  944,
+      945,  172,  946,  949,  950,  952,  954,  955,  957,  958,
+
+      172,  959,  960,  961,  943,  962,  963,  964,  172,  172,
+      172,  172,  172,  172,  965,  172,  966,  967,  968,  970,
+      971,  172,  972,  973,  974,  976,  977,  172,  218,  218,
+      218,  978,  980,  981,  982,  983,  984,  218,  218,  218,
+      218,  218,  218,  985,  986,  987,  989,  218,  990,  218,
+      991,  995,  997,  998, 1000, 1001, 1002, 1006, 1008, 1009,
+     1010, 1011, 1012, 1013, 1015, 1017, 1018, 1019,  218,  218,
+      218,  218,  218,  218, 1020, 1021, 1022,  218, 1024,  218,
+      290,  290,  290, 1025, 1026, 1029, 1031, 1032, 1034,  290,
+      290,  290,  290,  290,  290, 1036, 1037, 1038, 1039,  290,
+
+     1040,  290, 1041, 1042, 1043, 1044, 1045, 1010, 1009, 1046,
+     1047, 1050, 1051, 1052, 1053, 1054, 1056, 1058, 1059, 1060,
+      290,  290,  290,  290,  290,  290, 1061, 1062, 1064,  290,
+     1065,  290,  341,  341,  341, 1066, 1068, 1070, 1071, 1072,
+     1073,  341,  341,  341,  341,  341,  341, 1074, 1075, 1076,
+     1077,  341, 1078,  341, 1079, 1081, 1084, 1085, 1086, 1087,
+     1088, 1089, 1091, 1092, 1093, 1096, 1098, 1099, 1100, 1102,
+     1104, 1105,  341,  341,  341,  341,  341,  341, 1106, 1107,
+     1108,  341, 1109,  341,  403,  403,  403, 1110, 1111, 1112,
+     1113, 1114, 1115,  403,  403,  403,  403,  403,  403, 1118,
+
+     1119, 1120, 1121,  403, 1122,  403, 1126, 1127, 1128, 1132,
+     1133, 1134, 1135, 1137, 1138, 1139, 1140, 1141, 1143, 1144,
+     1146, 1147, 1148, 1150,  403,  403,  403,  403,  403,  403,
+     1153, 1154, 1155,  403, 1151,  403,  407,  407,  407, 1151,
+     1156, 1157, 1158, 1159, 1162,  407,  407,  407,  407,  407,
+      407, 1164, 1165, 1166, 1168,  407, 1169,  407, 1170, 1172,
+     1174, 1175, 1176, 1177, 1179, 1180, 1181, 1183, 1184, 1185,
+     1186, 1188, 1189, 1190, 1191, 1192,  407,  407,  407,  407,
+      407,  407, 1194, 1195, 1197,  407, 1198,  407,  830,  830,
+     1199,  830,  830,  830, 1200,  830,  830,  830,  830,  830,
+
+     1202,  830, 1203, 1205, 1206, 1207, 1208, 1203, 1209,  830,
+      830,  830,  830,  830, 1210, 1211, 1214, 1216, 1217, 1218,
+     1219, 1220, 1221, 1222, 1223, 1225, 1227, 1228, 1229, 1230,
+     1231, 1232, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1242,
+     1243, 1244, 1247,  830, 1249, 1251, 1252, 1254, 1255, 1256,
+     1257, 1258, 1259, 1262, 1244, 1264, 1266, 1267, 1268, 1269,
+     1270, 1271, 1273, 1274, 1275, 1276,  830,  830,  830,  846,
+      846, 1277,  846,  846,  846, 1278,  846,  846,  846,  846,
+      846, 1279,  846, 1280, 1282, 1283, 1284, 1287, 1295, 1296,
+      846,  846,  846,  846,  846, 1297, 1298, 1299, 1300, 1284,
+
+     1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1302,
+     1310, 1311, 1312, 1314, 1315, 1317, 1319, 1318, 1320, 1321,
+     1322, 1324, 1325, 1326,  846, 1318, 1327, 1328, 1329, 1331,
+     1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1332, 1340,
+     1341, 1342, 1343, 1344, 1345, 1346, 1347,  846,  846,  846,
+      993,  993, 1348,  993,  993,  993, 1349,  993,  993,  993,
+      993,  993, 1352,  993, 1353, 1354, 1355, 1357, 1358, 1359,
+     1360,  993,  993,  993,  993,  993, 1361, 1362, 1363, 1364,
+     1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376,
+     1377, 1380, 1381, 1382, 1383, 1385, 1386, 1387, 1388, 1389,
+
+     1390, 1391, 1392, 1393, 1394,  993, 1395, 1398, 1399, 1400,
+     1401, 1402, 1403, 1404, 1405, 1406, 1407, 1409, 1410, 1411,
+     1412, 1413, 1414, 1415, 1416, 1417, 1418, 1421,  993,  993,
+      993, 1004, 1004, 1422, 1004, 1004, 1004, 1423, 1004, 1004,
+     1004, 1004, 1004, 1424, 1004, 1425, 1426, 1427, 1428, 1430,
+     1431, 1433, 1004, 1004, 1004, 1004, 1004, 1434, 1435, 1436,
+     1438, 1439, 1440, 1442, 1443, 1445, 1446, 1447, 1448, 1450,
+     1451, 1453, 1454, 1455, 1456, 1458, 1459, 1460, 1462, 1463,
+     1464, 1465, 1466, 1468, 1464, 1470, 1004, 1471, 1472, 1473,
+     1474, 1476, 1477, 1473, 1478, 1479, 1480, 1464, 1481, 1479,
+
+     1483, 1485, 1486, 1487, 1488, 1489, 1473, 1490, 1491, 1004,
+     1004, 1004, 1479, 1492, 1493, 1496, 1498, 1499, 1500, 1504,
+     1505, 1506, 1507, 1508, 1509, 1512, 1514, 1515, 1516, 1517,
+     1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527,
+     1528, 1529, 1530, 1531, 1532, 1534, 1535, 1536, 1537, 1538,
+     1540, 1541, 1542, 1544, 1545, 1546, 1547, 1548, 1549, 1550,
+     1551, 1552, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1562,
+     1564, 1565, 1566, 1568, 1569, 1571, 1572, 1573, 1574, 1575,
+     1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585,
+     1586, 1587, 1588, 1589, 1590, 1591, 1593, 1594, 1595, 1596,
+
+     1598, 1599, 1600, 1602, 1603, 1606, 1607, 1609, 1611, 1612,
+     1613, 1617, 1617, 1617, 1617, 1617, 1617, 1617, 1617, 1617,
+     1617, 1617, 1618, 1618, 1618, 1618, 1618, 1618, 1618, 1618,
+     1618, 1618, 1618, 1619, 1619, 1619, 1619, 1619, 1619, 1619,
+     1619, 1619, 1619, 1619, 1620, 1620, 1620, 1620, 1620, 1620,
+     1620, 1620, 1620, 1620, 1620, 1621, 1621, 1621, 1621, 1621,
+     1621, 1621, 1621, 1621, 1621, 1621, 1622, 1622, 1622, 1622,
+     1622, 1622, 1622, 1622, 1622, 1622, 1622, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1624, 1635, 1624,  799, 1624,
+     1624, 1624, 1624, 1625,  798, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1626,  797,  796,  794,  793, 1626, 1626, 1626, 1627,
+     1627, 1627, 1627, 1627, 1627, 1627, 1627, 1627, 1627, 1627,
+     1628,  791, 1628,  790, 1628, 1628, 1628, 1628, 1629,  788,
+     1629, 1629, 1629, 1629, 1629, 1629, 1629, 1629, 1629, 1630,
+      787, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630,
+     1631,  786, 1631, 1631, 1631, 1631, 1631, 1631, 1631, 1631,
+     1631, 1632,  784, 1632, 1633, 1633, 1633,  783,  782, 1633,
+     1633,  781, 1633, 1634,  779, 1634,  778, 1634, 1634, 1634,
+     1634, 1636,  777, 1636, 1636, 1636, 1636, 1636, 1636, 1637,
+      776, 1637, 1637, 1637, 1637, 1637, 1637, 1637, 1637, 1637,
+
+     1638,  775, 1638, 1638, 1638, 1638, 1638, 1638, 1638, 1638,
+     1638, 1639,  774, 1639, 1639, 1639, 1639, 1639, 1639, 1639,
+     1639, 1639, 1640,  773, 1640, 1640, 1640, 1640, 1640, 1640,
+     1640, 1640, 1640,  771,  770,  768,  766,  765,  764,  763,
+      762,  760,  759,  758,  757,  756,  755,  754,  753,  752,
+      751,  750,  749,  748,  746,  745,  744,  741,  740,  739,
+      738,  737,  736,  734,  733,  732,  730,  729,  728,  726,
+      725,  724,  723,  722,  721,  720,  719,  718,  717,  716,
+      715,  714,  713,  712,  711,  710,  708,  707,  706,  705,
+      704,  703,  702,  701,  700,  698,  696,  695,  693,  692,
+
+      691,  689,  688,  687,  686,  684,  683,  682,  681,  680,
+      679,  678,  676,  674,  672,  671,  670,  669,  668,  666,
+      662,  661,  660,  659,  658,  657,  656,  655,  654,  653,
+      651,  650,  649,  647,  646,  645,  644,  643,  642,  641,
+      640,  639,  638,  637,  635,  634,  633,  631,  628,  625,
+      624,  623,  622,  621,  620,  619,  618,  617,  616,  615,
+      614,  613,  612,  611,  610,  609,  608,  607,  606,  605,
+      604,  603,  602,  601,  600,  599,  597,  594,  593,  592,
+      591,  590,  589,  588,  587,  586,  584,  583,  582,  581,
+      580,  579,  578,  577,  576,  575,  574,  573,  572,  571,
+
+      570,  569,  568,  567,  566,  565,  564,  563,  562,  561,
+      558,  557,  556,  555,  554,  553,  552,  551,  550,  549,
+      548,  547,  546,  545,  542,  541,  540,  539,  538,  537,
+      536,  535,  533,  532,  531,  530,  529,  528,  527,  526,
+      525,  523,  519,  516,  515,  514,  513,  512,  511,  510,
+      509,  508,  507,  506,  505,  504,  503,  502,  501,  500,
+      499,  498,  497,  496,  495,  494,  493,  492,  491,  490,
+      488,  487,  486,  485,  484,  483,  482,  481,  480,  478,
+      477,  476,  475,  474,  473,  472,  471,  470,  469,  468,
+      467,  466,  465,  464,  463,  462,  461,  460,  459,  458,
+
+      457,  456,  450,  449,  446,  445,  444,  443,  442,  441,
+      440,  439,  438,  437,  436,  435,  434,  431,  429,  428,
+      427,  426,  425,  424,  423,  422,  421,  420,  419,  418,
+      415,  404,  401,  400,  399,  398,  397,  396,  395,  394,
+      393,  392,  391,  390,  389,  388,  386,  385,  384,  383,
+      382,  381,  380,  379,  377,  376,  375,  374,  371,  370,
+      368,  367,  366,  365,  364,  362,  361,  360,  359,  358,
+      356,  355,  354,  353,  352,  349,  348,  347,  346,  339,
+      337,  336,  335,  334,  333,  332,  331,  330,  328,  327,
+      326,  325,  324,  323,  322,  320,  319,  318,  313,  312,
+
+      308,  286,  285,  284,  283,  282,  281,  280,  279,  278,
+      277,  276,  275,  274,  273,  271,  270,  269,  268,  267,
+      266,  265,  264,  262,  261,  260,  258,  257,  255,  254,
+      253,  252,  251,  249,  248,  247,  246,  245,  243,  242,
+      241,  240,  237,  236,  235,  234,  233,  229,  215,  213,
+      207,  201,  198,  196,  194,  193,  192,  183,  181,  180,
+      179,  170,  165,  163,  161,  160,  158,  150,  149,  148,
+      147,  146,  145,  143,  142,  136,  135,  134,  133,  116,
+      111,  106,  105,  104,   95,   85,   84,   78,   77,   76,
+       70,   69,   68,   67,   64,   63,   61,   60,   54,   53,
+
+       52,   51,   42,   34,   32,   31,   25,   24,   22,   19,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+#line 2 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+
+/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009
+   Free Software Foundation, Inc.
+   Written by Steve Chamberlain of Cygnus Support.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "safe-ctype.h"
+#include "bfdlink.h"
+#include "ld.h"
+#include "ldmisc.h"
+#include "ldexp.h"
+#include "ldlang.h"
+#include <ldgram.h>
+#include "ldfile.h"
+#include "ldlex.h"
+#include "ldmain.h"
+#include "libiberty.h"
+
+/* The type of top-level parser input.
+   yylex and yyparse (indirectly) both check this.  */
+input_type parser_input;
+
+/* Line number in the current input file.
+   (FIXME Actually, it doesn't appear to get reset for each file?)  */
+unsigned int lineno = 1;
+
+/* The string we are currently lexing, or NULL if we are reading a
+   file.  */
+const char *lex_string = NULL;
+
+/* Support for flex reading from more than one input file (stream).
+   `include_stack' is flex's input state for each open file;
+   `file_name_stack' is the file names.  `lineno_stack' is the current
+   line numbers.
+
+   If `include_stack_ptr' is 0, we haven't started reading anything yet.
+   Otherwise, stack elements 0 through `include_stack_ptr - 1' are valid.  */
+
+#undef YY_INPUT
+#define YY_INPUT(buf,result,max_size) yy_input (buf, &result, max_size)
+
+#define YY_NO_UNPUT
+
+#define MAX_INCLUDE_DEPTH 10
+static YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
+static const char *file_name_stack[MAX_INCLUDE_DEPTH];
+static unsigned int lineno_stack[MAX_INCLUDE_DEPTH];
+static unsigned int include_stack_ptr = 0;
+static int vers_node_nesting = 0;
+
+static void yy_input (char *, int *, int);
+static void comment (void);
+static void lex_warn_invalid (char *where, char *what);
+
+/* STATES
+	EXPRESSION	definitely in an expression
+	SCRIPT		definitely in a script
+	BOTH		either EXPRESSION or SCRIPT
+	DEFSYMEXP	in an argument to -defsym
+        MRI             in an MRI script
+	VERS_START	starting a Sun style mapfile
+	VERS_SCRIPT	a Sun style mapfile
+	VERS_NODE	a node within a Sun style mapfile
+*/
+#define RTOKEN(x)  {  yylval.token = x; return x; }
+
+/* Some versions of flex want this.  */
+#ifndef yywrap
+int yywrap (void) { return 1; }
+#endif
+
+
+
+
+
+
+
+
+#line 1691 "ldlex.c"
+
+#define INITIAL 0
+#define SCRIPT 1
+#define EXPRESSION 2
+#define BOTH 3
+#define DEFSYMEXP 4
+#define MRI 5
+#define VERS_START 6
+#define VERS_SCRIPT 7
+#define VERS_NODE 8
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 117 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+
+
+  if (parser_input != input_selected)
+    {
+      /* The first token of the input determines the initial parser state.  */
+      input_type t = parser_input;
+      parser_input = input_selected;
+      switch (t)
+	{
+	case input_script: return INPUT_SCRIPT; break;
+	case input_mri_script: return INPUT_MRI_SCRIPT; break;
+	case input_version_script: return INPUT_VERSION_SCRIPT; break;
+	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
+	case input_defsym: return INPUT_DEFSYM; break;
+	default: abort ();
+	}
+    }
+
+#line 1905 "ldlex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 1617 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 2611 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 135 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ comment (); }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 138 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('-');}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 139 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('+');}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 140 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ yylval.name = xstrdup (yytext); return NAME; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 141 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('='); }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 143 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+  				yylval.integer = bfd_scan_vma (yytext + 1, 0, 16);
+				yylval.bigint.str = NULL;
+				return INT;
+			}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 149 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+				   int ibase ;
+				   switch (yytext[yyleng - 1]) {
+				    case 'X':
+				    case 'x':
+				    case 'H':
+				    case 'h':
+				     ibase = 16;
+				     break;
+				    case 'O':
+				    case 'o':
+				     ibase = 8;
+				     break;
+				    case 'B':
+				    case 'b':
+				     ibase = 2;
+				     break;
+				    default:
+				     ibase = 10;
+				   }
+				   yylval.integer = bfd_scan_vma (yytext, 0,
+								  ibase);
+				   yylval.bigint.str = NULL;
+				   return INT;
+				 }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 174 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+				  char *s = yytext;
+				  int ibase = 0;
+
+				  if (*s == '$')
+				    {
+				      ++s;
+				      ibase = 16;
+				    }
+				  yylval.integer = bfd_scan_vma (s, 0, ibase);
+				  yylval.bigint.str = NULL;
+				  if (yytext[yyleng - 1] == 'M'
+				      || yytext[yyleng - 1] == 'm')
+				    {
+				      yylval.integer *= 1024 * 1024;
+				    }
+				  else if (yytext[yyleng - 1] == 'K'
+				      || yytext[yyleng - 1]=='k')
+				    {
+				      yylval.integer *= 1024;
+				    }
+				  else if (yytext[0] == '0'
+					   && (yytext[1] == 'x'
+					       || yytext[1] == 'X'))
+				    {
+				      yylval.bigint.str = xstrdup (yytext + 2);
+				    }
+				  return INT;
+				}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 203 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(']');}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 204 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('[');}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 205 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LSHIFTEQ);}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 206 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(RSHIFTEQ);}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 207 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(OROR);}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 208 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(EQ);}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 209 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NE);}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 210 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(GE);}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 211 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LE);}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 212 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LSHIFT);}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 213 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(RSHIFT);}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 214 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(PLUSEQ);}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 215 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(MINUSEQ);}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 216 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(MULTEQ);}
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 217 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(DIVEQ);}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 218 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ANDEQ);}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 219 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(OREQ);}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 220 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ANDAND);}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 221 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('>');}
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 222 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(',');}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 223 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('&');}
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 224 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('|');}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 225 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('~');}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 226 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('!');}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 227 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('?');}
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 228 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('*');}
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 229 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('+');}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 230 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('-');}
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 231 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('/');}
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 232 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('%');}
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 233 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('<');}
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 234 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('=');}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 235 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('}') ; }
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 236 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('{'); }
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 237 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(')');}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 238 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN('(');}
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 239 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(':'); }
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 240 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(';');}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 241 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(MEMORY);}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 242 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(REGION_ALIAS);}
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 243 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ORIGIN);}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 244 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(VERSIONK);}
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 245 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(BLOCK);}
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 246 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(BIND);}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 247 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LENGTH);}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 248 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIGN_K);}
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 249 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(DATA_SEGMENT_ALIGN);}
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 250 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(DATA_SEGMENT_RELRO_END);}
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 251 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(DATA_SEGMENT_END);}
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 252 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ADDR);}
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 253 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LOADADDR);}
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 254 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIGNOF); }
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 255 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(MAX_K); }
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 256 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(MIN_K); }
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 257 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CEILP2); }
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 258 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NACL_MASK);}
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 259 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ASSERT_K); }
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 260 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ENTRY);}
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+#line 261 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(EXTERN);}
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 262 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NEXT);}
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 263 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SIZEOF_HEADERS);}
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 264 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SIZEOF_HEADERS);}
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 265 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SEGMENT_START);}
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 266 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(MAP);}
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 267 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SIZEOF);}
+	YY_BREAK
+case 74:
+YY_RULE_SETUP
+#line 268 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(TARGET_K);}
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+#line 269 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SEARCH_DIR);}
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+#line 270 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(OUTPUT);}
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 271 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(INPUT);}
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+#line 272 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(GROUP);}
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+#line 273 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(AS_NEEDED);}
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+#line 274 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(DEFINED);}
+	YY_BREAK
+case 81:
+YY_RULE_SETUP
+#line 275 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CREATE_OBJECT_SYMBOLS);}
+	YY_BREAK
+case 82:
+YY_RULE_SETUP
+#line 276 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( CONSTRUCTORS);}
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+#line 277 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(FORCE_COMMON_ALLOCATION);}
+	YY_BREAK
+case 84:
+YY_RULE_SETUP
+#line 278 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(INHIBIT_COMMON_ALLOCATION);}
+	YY_BREAK
+case 85:
+YY_RULE_SETUP
+#line 279 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SECTIONS);}
+	YY_BREAK
+case 86:
+YY_RULE_SETUP
+#line 280 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(INSERT_K);}
+	YY_BREAK
+case 87:
+YY_RULE_SETUP
+#line 281 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(AFTER);}
+	YY_BREAK
+case 88:
+YY_RULE_SETUP
+#line 282 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(BEFORE);}
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+#line 283 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(FILL);}
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+#line 284 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(STARTUP);}
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+#line 285 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(OUTPUT_FORMAT);}
+	YY_BREAK
+case 92:
+YY_RULE_SETUP
+#line 286 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( OUTPUT_ARCH);}
+	YY_BREAK
+case 93:
+YY_RULE_SETUP
+#line 287 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(HLL);}
+	YY_BREAK
+case 94:
+YY_RULE_SETUP
+#line 288 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SYSLIB);}
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+#line 289 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(FLOAT);}
+	YY_BREAK
+case 96:
+YY_RULE_SETUP
+#line 290 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( QUAD);}
+	YY_BREAK
+case 97:
+YY_RULE_SETUP
+#line 291 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( SQUAD);}
+	YY_BREAK
+case 98:
+YY_RULE_SETUP
+#line 292 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( LONG);}
+	YY_BREAK
+case 99:
+YY_RULE_SETUP
+#line 293 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( SHORT);}
+	YY_BREAK
+case 100:
+YY_RULE_SETUP
+#line 294 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( BYTE);}
+	YY_BREAK
+case 101:
+YY_RULE_SETUP
+#line 295 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NOFLOAT);}
+	YY_BREAK
+case 102:
+YY_RULE_SETUP
+#line 296 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NOCROSSREFS);}
+	YY_BREAK
+case 103:
+YY_RULE_SETUP
+#line 297 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(OVERLAY); }
+	YY_BREAK
+case 104:
+YY_RULE_SETUP
+#line 298 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SORT_BY_NAME); }
+	YY_BREAK
+case 105:
+YY_RULE_SETUP
+#line 299 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SORT_BY_ALIGNMENT); }
+	YY_BREAK
+case 106:
+YY_RULE_SETUP
+#line 300 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SORT_BY_NAME); }
+	YY_BREAK
+case 107:
+YY_RULE_SETUP
+#line 301 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NOLOAD);}
+	YY_BREAK
+case 108:
+YY_RULE_SETUP
+#line 302 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(DSECT);}
+	YY_BREAK
+case 109:
+YY_RULE_SETUP
+#line 303 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(COPY);}
+	YY_BREAK
+case 110:
+YY_RULE_SETUP
+#line 304 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(INFO);}
+	YY_BREAK
+case 111:
+YY_RULE_SETUP
+#line 305 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(OVERLAY);}
+	YY_BREAK
+case 112:
+YY_RULE_SETUP
+#line 306 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ONLY_IF_RO); }
+	YY_BREAK
+case 113:
+YY_RULE_SETUP
+#line 307 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ONLY_IF_RW); }
+	YY_BREAK
+case 114:
+YY_RULE_SETUP
+#line 308 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SPECIAL); }
+	YY_BREAK
+case 115:
+YY_RULE_SETUP
+#line 309 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ORIGIN);}
+	YY_BREAK
+case 116:
+YY_RULE_SETUP
+#line 310 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ORIGIN);}
+	YY_BREAK
+case 117:
+YY_RULE_SETUP
+#line 311 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( LENGTH);}
+	YY_BREAK
+case 118:
+YY_RULE_SETUP
+#line 312 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN( LENGTH);}
+	YY_BREAK
+case 119:
+YY_RULE_SETUP
+#line 313 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(INCLUDE);}
+	YY_BREAK
+case 120:
+YY_RULE_SETUP
+#line 314 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN (PHDRS); }
+	YY_BREAK
+case 121:
+YY_RULE_SETUP
+#line 315 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(AT);}
+	YY_BREAK
+case 122:
+YY_RULE_SETUP
+#line 316 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SUBALIGN);}
+	YY_BREAK
+case 123:
+YY_RULE_SETUP
+#line 317 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(PROVIDE); }
+	YY_BREAK
+case 124:
+YY_RULE_SETUP
+#line 318 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(PROVIDE_HIDDEN); }
+	YY_BREAK
+case 125:
+YY_RULE_SETUP
+#line 319 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(KEEP); }
+	YY_BREAK
+case 126:
+YY_RULE_SETUP
+#line 320 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(EXCLUDE_FILE); }
+	YY_BREAK
+case 127:
+YY_RULE_SETUP
+#line 321 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CONSTANT);}
+	YY_BREAK
+case 128:
+/* rule 128 can match eol */
+YY_RULE_SETUP
+#line 322 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ ++ lineno; }
+	YY_BREAK
+case 129:
+/* rule 129 can match eol */
+YY_RULE_SETUP
+#line 323 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ ++ lineno;  RTOKEN(NEWLINE); }
+	YY_BREAK
+case 130:
+YY_RULE_SETUP
+#line 324 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ /* Mri comment line */ }
+	YY_BREAK
+case 131:
+YY_RULE_SETUP
+#line 325 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ /* Mri comment line */ }
+	YY_BREAK
+case 132:
+YY_RULE_SETUP
+#line 326 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ENDWORD); }
+	YY_BREAK
+case 133:
+YY_RULE_SETUP
+#line 327 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIGNMOD);}
+	YY_BREAK
+case 134:
+YY_RULE_SETUP
+#line 328 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIGN_K);}
+	YY_BREAK
+case 135:
+YY_RULE_SETUP
+#line 329 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CHIP); }
+	YY_BREAK
+case 136:
+YY_RULE_SETUP
+#line 330 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(BASE); }
+	YY_BREAK
+case 137:
+YY_RULE_SETUP
+#line 331 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIAS); }
+	YY_BREAK
+case 138:
+YY_RULE_SETUP
+#line 332 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(TRUNCATE); }
+	YY_BREAK
+case 139:
+YY_RULE_SETUP
+#line 333 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LOAD); }
+	YY_BREAK
+case 140:
+YY_RULE_SETUP
+#line 334 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(PUBLIC); }
+	YY_BREAK
+case 141:
+YY_RULE_SETUP
+#line 335 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ORDER); }
+	YY_BREAK
+case 142:
+YY_RULE_SETUP
+#line 336 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NAMEWORD); }
+	YY_BREAK
+case 143:
+YY_RULE_SETUP
+#line 337 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(FORMAT); }
+	YY_BREAK
+case 144:
+YY_RULE_SETUP
+#line 338 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CASE); }
+	YY_BREAK
+case 145:
+YY_RULE_SETUP
+#line 339 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(START); }
+	YY_BREAK
+case 146:
+YY_RULE_SETUP
+#line 340 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
+	YY_BREAK
+case 147:
+YY_RULE_SETUP
+#line 341 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SECT); }
+	YY_BREAK
+case 148:
+YY_RULE_SETUP
+#line 342 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ABSOLUTE); }
+	YY_BREAK
+case 149:
+YY_RULE_SETUP
+#line 343 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ENDWORD); }
+	YY_BREAK
+case 150:
+YY_RULE_SETUP
+#line 344 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIGNMOD);}
+	YY_BREAK
+case 151:
+YY_RULE_SETUP
+#line 345 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIGN_K);}
+	YY_BREAK
+case 152:
+YY_RULE_SETUP
+#line 346 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CHIP); }
+	YY_BREAK
+case 153:
+YY_RULE_SETUP
+#line 347 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(BASE); }
+	YY_BREAK
+case 154:
+YY_RULE_SETUP
+#line 348 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ALIAS); }
+	YY_BREAK
+case 155:
+YY_RULE_SETUP
+#line 349 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(TRUNCATE); }
+	YY_BREAK
+case 156:
+YY_RULE_SETUP
+#line 350 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LOAD); }
+	YY_BREAK
+case 157:
+YY_RULE_SETUP
+#line 351 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(PUBLIC); }
+	YY_BREAK
+case 158:
+YY_RULE_SETUP
+#line 352 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ORDER); }
+	YY_BREAK
+case 159:
+YY_RULE_SETUP
+#line 353 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(NAMEWORD); }
+	YY_BREAK
+case 160:
+YY_RULE_SETUP
+#line 354 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(FORMAT); }
+	YY_BREAK
+case 161:
+YY_RULE_SETUP
+#line 355 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(CASE); }
+	YY_BREAK
+case 162:
+YY_RULE_SETUP
+#line 356 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(EXTERN); }
+	YY_BREAK
+case 163:
+YY_RULE_SETUP
+#line 357 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(START); }
+	YY_BREAK
+case 164:
+YY_RULE_SETUP
+#line 358 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
+	YY_BREAK
+case 165:
+YY_RULE_SETUP
+#line 359 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(SECT); }
+	YY_BREAK
+case 166:
+YY_RULE_SETUP
+#line 360 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(ABSOLUTE); }
+	YY_BREAK
+case 167:
+YY_RULE_SETUP
+#line 362 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+/* Filename without commas, needed to parse mri stuff */
+				 yylval.name = xstrdup (yytext);
+				  return NAME;
+				}
+	YY_BREAK
+case 168:
+YY_RULE_SETUP
+#line 369 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+				 yylval.name = xstrdup (yytext);
+				  return NAME;
+				}
+	YY_BREAK
+case 169:
+YY_RULE_SETUP
+#line 373 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+				  yylval.name = xstrdup (yytext + 2);
+				  return LNAME;
+				}
+	YY_BREAK
+case 170:
+YY_RULE_SETUP
+#line 377 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+				 yylval.name = xstrdup (yytext);
+				  return NAME;
+				}
+	YY_BREAK
+case 171:
+YY_RULE_SETUP
+#line 381 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+				  yylval.name = xstrdup (yytext + 2);
+				  return LNAME;
+				}
+	YY_BREAK
+case 172:
+YY_RULE_SETUP
+#line 385 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+		/* Annoyingly, this pattern can match comments, and we have
+		   longest match issues to consider.  So if the first two
+		   characters are a comment opening, put the input back and
+		   try again.  */
+		if (yytext[0] == '/' && yytext[1] == '*')
+		  {
+		    yyless (2);
+		    comment ();
+		  }
+		else
+		  {
+		    yylval.name = xstrdup (yytext);
+		    return NAME;
+		  }
+	}
+	YY_BREAK
+case 173:
+/* rule 173 can match eol */
+YY_RULE_SETUP
+#line 402 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+					/* No matter the state, quotes
+					   give what's inside */
+					yylval.name = xstrdup (yytext + 1);
+					yylval.name[yyleng - 2] = 0;
+					return NAME;
+				}
+	YY_BREAK
+case 174:
+/* rule 174 can match eol */
+YY_RULE_SETUP
+#line 409 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ lineno++;}
+	YY_BREAK
+case 175:
+YY_RULE_SETUP
+#line 410 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ }
+	YY_BREAK
+case 176:
+YY_RULE_SETUP
+#line 412 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ return *yytext; }
+	YY_BREAK
+case 177:
+YY_RULE_SETUP
+#line 414 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(GLOBAL); }
+	YY_BREAK
+case 178:
+YY_RULE_SETUP
+#line 416 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(LOCAL); }
+	YY_BREAK
+case 179:
+YY_RULE_SETUP
+#line 418 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ RTOKEN(EXTERN); }
+	YY_BREAK
+case 180:
+YY_RULE_SETUP
+#line 420 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ yylval.name = xstrdup (yytext);
+				  return VERS_IDENTIFIER; }
+	YY_BREAK
+case 181:
+YY_RULE_SETUP
+#line 423 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ yylval.name = xstrdup (yytext);
+				  return VERS_TAG; }
+	YY_BREAK
+case 182:
+YY_RULE_SETUP
+#line 426 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ BEGIN(VERS_SCRIPT); return *yytext; }
+	YY_BREAK
+case 183:
+YY_RULE_SETUP
+#line 428 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ BEGIN(VERS_NODE);
+				  vers_node_nesting = 0;
+				  return *yytext;
+				}
+	YY_BREAK
+case 184:
+YY_RULE_SETUP
+#line 432 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ return *yytext; }
+	YY_BREAK
+case 185:
+YY_RULE_SETUP
+#line 433 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ vers_node_nesting++; return *yytext; }
+	YY_BREAK
+case 186:
+YY_RULE_SETUP
+#line 434 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ if (--vers_node_nesting < 0)
+				    BEGIN(VERS_SCRIPT);
+				  return *yytext;
+				}
+	YY_BREAK
+case 187:
+/* rule 187 can match eol */
+YY_RULE_SETUP
+#line 439 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ lineno++; }
+	YY_BREAK
+case 188:
+YY_RULE_SETUP
+#line 441 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ /* Eat up comments */ }
+	YY_BREAK
+case 189:
+YY_RULE_SETUP
+#line 443 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{ /* Eat up whitespace */ }
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(SCRIPT):
+case YY_STATE_EOF(EXPRESSION):
+case YY_STATE_EOF(BOTH):
+case YY_STATE_EOF(DEFSYMEXP):
+case YY_STATE_EOF(MRI):
+case YY_STATE_EOF(VERS_START):
+case YY_STATE_EOF(VERS_SCRIPT):
+case YY_STATE_EOF(VERS_NODE):
+#line 445 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+{
+  include_stack_ptr--;
+
+  if (include_stack_ptr == 0)
+  {
+    yyterminate ();
+  }
+  else
+  {
+    yy_switch_to_buffer (include_stack[include_stack_ptr]);
+  }
+
+  ldfile_input_filename = file_name_stack[include_stack_ptr - 1];
+  lineno = lineno_stack[include_stack_ptr];
+
+  return END;
+}
+	YY_BREAK
+case 190:
+YY_RULE_SETUP
+#line 463 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+lex_warn_invalid (" in script", yytext);
+	YY_BREAK
+case 191:
+YY_RULE_SETUP
+#line 464 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+lex_warn_invalid (" in expression", yytext);
+	YY_BREAK
+case 192:
+YY_RULE_SETUP
+#line 466 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+ECHO;
+	YY_BREAK
+#line 3082 "ldlex.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 1617 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 1617 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 1616);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 466 "../../binutils-2.19.51.20090622/ld/ldlex.l"
+
+
+
+
+/* Switch flex to reading script file NAME, open on FILE,
+   saving the current input info on the include stack.  */
+
+void
+lex_push_file (FILE *file, const char *name)
+{
+  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
+    {
+      einfo ("%F:includes nested too deeply\n");
+    }
+  file_name_stack[include_stack_ptr] = name;
+  lineno_stack[include_stack_ptr] = lineno;
+  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
+
+  include_stack_ptr++;
+  lineno = 1;
+  yyin = file;
+  yy_switch_to_buffer (yy_create_buffer (yyin, YY_BUF_SIZE));
+}
+
+/* Return a newly created flex input buffer containing STRING,
+   which is SIZE bytes long.  */
+
+static YY_BUFFER_STATE
+yy_create_string_buffer (const char *string, size_t size)
+{
+  YY_BUFFER_STATE b;
+
+  /* Calls to m-alloc get turned by sed into xm-alloc.  */
+  b = malloc (sizeof (struct yy_buffer_state));
+  b->yy_input_file = 0;
+  b->yy_buf_size = size;
+
+  /* yy_ch_buf has to be 2 characters longer than the size given because
+     we need to put in 2 end-of-buffer characters.  */
+  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));
+
+  b->yy_ch_buf[0] = '\n';
+  strcpy (b->yy_ch_buf+1, string);
+  b->yy_ch_buf[size+1] = YY_END_OF_BUFFER_CHAR;
+  b->yy_ch_buf[size+2] = YY_END_OF_BUFFER_CHAR;
+  b->yy_n_chars = size+1;
+  b->yy_buf_pos = &b->yy_ch_buf[1];
+
+  b->yy_is_our_buffer = 1;
+  b->yy_is_interactive = 0;
+  b->yy_at_bol = 1;
+  b->yy_fill_buffer = 0;
+
+  /* flex 2.4.7 changed the interface.  FIXME: We should not be using
+     a flex internal interface in the first place!  */
+#ifdef YY_BUFFER_NEW
+  b->yy_buffer_status = YY_BUFFER_NEW;
+#else
+  b->yy_eof_status = EOF_NOT_SEEN;
+#endif
+
+  return b;
+}
+
+/* Switch flex to reading from STRING, saving the current input info
+   on the include stack.  */
+
+void
+lex_redirect (const char *string)
+{
+  YY_BUFFER_STATE tmp;
+
+  yy_init = 0;
+  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
+    {
+      einfo("%F: macros nested too deeply\n");
+    }
+  file_name_stack[include_stack_ptr] = "redirect";
+  lineno_stack[include_stack_ptr] = lineno;
+  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
+  include_stack_ptr++;
+  lineno = 1;
+  tmp = yy_create_string_buffer (string, strlen (string));
+  yy_switch_to_buffer (tmp);
+}
+
+/* Functions to switch to a different flex start condition,
+   saving the current start condition on `state_stack'.  */
+
+static int state_stack[MAX_INCLUDE_DEPTH * 2];
+static int *state_stack_p = state_stack;
+
+void
+ldlex_script (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (SCRIPT);
+}
+
+void
+ldlex_mri_script (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (MRI);
+}
+
+void
+ldlex_version_script (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (VERS_START);
+}
+
+void
+ldlex_version_file (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (VERS_SCRIPT);
+}
+
+void
+ldlex_defsym (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (DEFSYMEXP);
+}
+
+void
+ldlex_expression (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (EXPRESSION);
+}
+
+void
+ldlex_both (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (BOTH);
+}
+
+void
+ldlex_popstate (void)
+{
+  yy_start = *(--state_stack_p);
+}
+
+
+/* Place up to MAX_SIZE characters in BUF and return in *RESULT
+   either the number of characters read, or 0 to indicate EOF.  */
+
+static void
+yy_input (char *buf, int *result, int max_size)
+{
+  *result = 0;
+  if (YY_CURRENT_BUFFER->yy_input_file)
+    {
+      if (yyin)
+	{
+	  *result = fread (buf, 1, max_size, yyin);
+	  if (*result < max_size && ferror (yyin))
+	    einfo ("%F%P: read in flex scanner failed\n");
+	}
+    }
+}
+
+/* Eat the rest of a C-style comment.  */
+
+static void
+comment (void)
+{
+  int c;
+
+  while (1)
+  {
+    c = input();
+    while (c != '*' && c != EOF)
+    {
+      if (c == '\n')
+	lineno++;
+      c = input();
+    }
+
+    if (c == '*')
+    {
+      c = input();
+      while (c == '*')
+       c = input();
+      if (c == '/')
+       break;			/* found the end */
+    }
+
+    if (c == '\n')
+      lineno++;
+
+    if (c == EOF)
+    {
+      einfo( "%F%P: EOF in comment\n");
+      break;
+    }
+  }
+}
+
+/* Warn the user about a garbage character WHAT in the input
+   in context WHERE.  */
+
+static void
+lex_warn_invalid (char *where, char *what)
+{
+  char buf[5];
+
+  /* If we have found an input file whose format we do not recognize,
+     and we are therefore treating it as a linker script, and we find
+     an invalid character, then most likely this is a real object file
+     of some different format.  Treat it as such.  */
+  if (ldfile_assumed_script)
+    {
+      bfd_set_error (bfd_error_file_not_recognized);
+      einfo ("%F%s: file not recognized: %E\n", ldfile_input_filename);
+    }
+
+  if (! ISPRINT (*what))
+    {
+      sprintf (buf, "\\%03o", (unsigned int) *what);
+      what = buf;
+    }
+
+  einfo ("%P:%S: ignoring invalid character `%s'%s\n", what, where);
+}
+
