<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Native Client: Pthread</title>
    <link href="./tabs.css" rel="stylesheet" type="text/css">
    <link href="./stylesheet-dox.css" rel="stylesheet" type="text/css">
    <link href="./stylesheet-dox-all.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div id="toplinks">
      <a href="../../../README.html">Back to README</a>
    </div>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Pthread<br>
<small>
[<a class="el" href="group___libraries.html">Libraries</a>]</small>
</h1>A POSIX-based threads API.  
<a href="#_details">More...</a>
<p>
<h2>Data Structures</h2>
<ul>
<li>struct <a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a>
<dl class="el"><dd class="mdescRight">A structure representing a thread mutex.  <a href="structpthread__mutex__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a>
<dl class="el"><dd class="mdescRight">A structure representing mutex attributes.  <a href="structpthread__mutexattr__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structpthread__cond__t.html">pthread_cond_t</a>
<dl class="el"><dd class="mdescRight">A structure representing a condition variable.  <a href="structpthread__cond__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structpthread__condattr__t.html">pthread_condattr_t</a>
<dl class="el"><dd class="mdescRight">A structure representing condition variable attributes.  <a href="structpthread__condattr__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structpthread__attr__t.html">pthread_attr_t</a>
<dl class="el"><dd class="mdescRight">A structure representing thread attributes.  <a href="structpthread__attr__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structpthread__once__t.html">pthread_once_t</a>
<dl class="el"><dd class="mdescRight">A structure describing a control block used with the <a class="el" href="group___pthread.html#g3107d6f08955edec3467e2a01c668eb4" title="[not quite POSIX] Ensures that a piece of initialization code is executed at most...">pthread_once()</a> function.  <a href="structpthread__once__t.html#_details">More...</a><br></dl></ul>
<h2>Defines</h2>
<ul>
<li>#define <a class="el" href="group___pthread.html#g19223e28eb0b44c645adf508acf580d6">PTHREAD_MUTEX_FAST_NP</a>&nbsp;&nbsp;&nbsp;0
<li>#define <a class="el" href="group___pthread.html#g24a251d355bd6ed4c72963740a579cc5">PTHREAD_MUTEX_RECURSIVE_NP</a>&nbsp;&nbsp;&nbsp;1
<li>#define <a class="el" href="group___pthread.html#g103cfe33413e92a1c25cb17b943e2edb">PTHREAD_MUTEX_ERRORCHECK_NP</a>&nbsp;&nbsp;&nbsp;2
<li>#define <a class="el" href="group___pthread.html#g2d3db10a8cc49ec7afef746b09f84d7a">NC_INVALID_HANDLE</a>&nbsp;&nbsp;&nbsp;-1
<li>#define <a class="el" href="group___pthread.html#gc0b1f67334a9ee234f0754122d55f0ac">MAX_THREAD_ID</a>&nbsp;&nbsp;&nbsp;(0xfffffffe)
<li>#define <a class="el" href="group___pthread.html#g30790df7d4c04bece5751a8f55a96635">NACL_PTHREAD_ILLEGAL_THREAD_ID</a>&nbsp;&nbsp;&nbsp;(0xffffffff)
<li>#define <a class="el" href="group___pthread.html#gc2663553b072167a403521db5b4e82c4">PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</a>&nbsp;&nbsp;&nbsp;{0, 1, NACL_PTHREAD_ILLEGAL_THREAD_ID, 0, NC_INVALID_HANDLE}
<li>#define <a class="el" href="group___pthread.html#g84e55100366a6a8338a2af3b3f279686">PTHREAD_MUTEX_INITIALIZER</a>&nbsp;&nbsp;&nbsp;{0, 0, NACL_PTHREAD_ILLEGAL_THREAD_ID, 0, NC_INVALID_HANDLE}
<li>#define <a class="el" href="group___pthread.html#gcff148607c8534833336adb03d3f7b5b">PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</a>&nbsp;&nbsp;&nbsp;{0, 2, NACL_PTHREAD_ILLEGAL_THREAD_ID, 0, NC_INVALID_HANDLE}
<li>#define <a class="el" href="group___pthread.html#ga7b867fe46f3660283fcb356c4fcbbf0">PTHREAD_COND_INITIALIZER</a>&nbsp;&nbsp;&nbsp;{0, NC_INVALID_HANDLE}
<li>#define <a class="el" href="group___pthread.html#ge96b861c8d74168ee14ef2691a64ff91">pthread_cond_timedwait</a>&nbsp;&nbsp;&nbsp;pthread_cond_timedwait_abs
<li>#define <a class="el" href="group___pthread.html#gfb10d234d831c7b57768d62786748bc7">PTHREAD_CREATE_JOINABLE</a>&nbsp;&nbsp;&nbsp;1
<li>#define <a class="el" href="group___pthread.html#g391c5eb0f6b5febc48710d0be3f62394">PTHREAD_CREATE_DETACHED</a>&nbsp;&nbsp;&nbsp;0
<li>#define <a class="el" href="group___pthread.html#g0a23e66e087bcf5c253b9b2746f19a64">PTHREAD_KEYS_MAX</a>&nbsp;&nbsp;&nbsp;512
<li>#define <a class="el" href="group___pthread.html#g59e22497b65fc305ddb5cea8b4990b51">PTHREAD_ONCE_INIT</a>&nbsp;&nbsp;&nbsp;{0, PTHREAD_MUTEX_INITIALIZER}
</ul>
<h2>Typedefs</h2>
<ul>
<li>typedef void *(* <a class="el" href="group___pthread.html#g5e5de7274261aeace765f3dff906b76a">nc_thread_function</a> )(void *p)
<li>typedef uint32_t <a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a>
<li>typedef int <a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a>
</ul>
<h2>Functions</h2>
<ul>
<li>int <a class="el" href="group___pthread.html#g7c40d08c34d2416ffa1ab8436757a92f">pthread_mutex_init</a> (<a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex, <a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *mutex_attr)
<li>int <a class="el" href="group___pthread.html#g3cf620ff3a40af11d79cf28901dc55e2">pthread_mutex_destroy</a> (<a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex)
<li>int <a class="el" href="group___pthread.html#g27da386211db1a7e9a3b2a0db4d22144">pthread_mutex_trylock</a> (<a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex)
<li>int <a class="el" href="group___pthread.html#g12809c44718c21544ceb280dc1a53573">pthread_mutex_lock</a> (<a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex)
<li>int <a class="el" href="group___pthread.html#g96184290ffb60e04c53a52869cf960a2">pthread_mutex_unlock</a> (<a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex)
<li>int <a class="el" href="group___pthread.html#gf98f6b6c483077a39d1400b1de1577b8">pthread_mutexattr_init</a> (<a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *attr)
<li>int <a class="el" href="group___pthread.html#g2321aabf58224b06021185708d0f9658">pthread_mutexattr_destroy</a> (<a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *attr)
<li>int <a class="el" href="group___pthread.html#g4676cf36cad3bde781928419735e6fb7">pthread_mutexattr_settype</a> (<a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *attr, int kind)
<li>int <a class="el" href="group___pthread.html#gb095da0afa402ababcdc75b77e3ce2a8">pthread_mutexattr_gettype</a> (const <a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *attr, int *kind)
<li>int <a class="el" href="group___pthread.html#g46e1d6e885975dee1a31339a08bf09be">pthread_cond_init</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond, <a class="el" href="structpthread__condattr__t.html">pthread_condattr_t</a> *cond_attr)
<li>int <a class="el" href="group___pthread.html#ga1587e01856a579b78effd0a1a284a47">pthread_cond_destroy</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond)
<li>int <a class="el" href="group___pthread.html#g20f98235b024efb10e5c76a64f0d94e5">pthread_cond_signal</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond)
<li>int <a class="el" href="group___pthread.html#gfc4b19aa8ea2dce0956579ce878b4998">pthread_cond_broadcast</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond)
<li>int <a class="el" href="group___pthread.html#g907ae104b6dfd8fc12e23e84952aa7ca">pthread_cond_wait</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond, <a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex)
<li>int <a class="el" href="group___pthread.html#g54b88b0efacf9daf6adfe1c6d2d0d8f2">pthread_cond_timedwait_abs</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond, <a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex, struct timespec *abstime)
<li>int <a class="el" href="group___pthread.html#gd6871806d633bce2f65b49b5ac8557dc">pthread_cond_timedwait_rel</a> (<a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *cond, <a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *mutex, struct timespec *reltime)
<li>int <a class="el" href="group___pthread.html#gb4643e8af2b936d971d3248ec70507e1">pthread_create</a> (<a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> *thread_id, <a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *attr, void *(*start_routine)(void *p), void *arg)
<li><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> <a class="el" href="group___pthread.html#g4c4f5f3b4f8f45d9d897847d53b11aaa">pthread_self</a> (void)
<li>int <a class="el" href="group___pthread.html#g62b59b2f2765bba485afc979e6e24c9a">pthread_equal</a> (<a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> thread1, <a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> thread2)
<li>void <a class="el" href="group___pthread.html#g23b28e0f8ac5af2b46a33cdab3a80e44">pthread_exit</a> (void *retval)
<li>int <a class="el" href="group___pthread.html#ga98e330a54fc8c376b4b7bc5121e8513">pthread_join</a> (<a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> th, void **thread_return)
<li>int <a class="el" href="group___pthread.html#g28a542ad2b8f7e58cc102a599c556b4a">pthread_detach</a> (<a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> th)
<li>int <a class="el" href="group___pthread.html#g6a65d6ba3fc51aa5e30ef225307fb1bb">nacl_thread_nice</a> (const int nice)
<li>int <a class="el" href="group___pthread.html#g0b85ebb1e3aac081a4c0a5e85ae3cbe9">pthread_attr_init</a> (<a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *attr)
<li>int <a class="el" href="group___pthread.html#g4bcdbf47c17c7dcc51e9f05f5cb56d81">pthread_attr_destroy</a> (<a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *attr)
<li>int <a class="el" href="group___pthread.html#ge6ee78c307d8467b34a9b0c330993a54">pthread_attr_setdetachstate</a> (<a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *attr, int detachstate)
<li>int <a class="el" href="group___pthread.html#gc97de7a8a6d460109843215a81a52f7c">pthread_attr_getdetachstate</a> (<a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *attr, int *detachstate)
<li>int <a class="el" href="group___pthread.html#gb4a3d557336099397ec0baf627a88e61">pthread_key_create</a> (<a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a> *key, void(*destr_function)(void *p))
<li>int <a class="el" href="group___pthread.html#gee96306dc79294927ee840bb4de2244b">pthread_key_delete</a> (<a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a> key)
<li>int <a class="el" href="group___pthread.html#gc4a911634124e77dd075b1976712e801">pthread_setspecific</a> (<a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a> key, const void *pointer)
<li>void * <a class="el" href="group___pthread.html#g31469375891078185bda93f0e4411a2c">pthread_getspecific</a> (<a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a> key)
<li>int <a class="el" href="group___pthread.html#g3107d6f08955edec3467e2a01c668eb4">pthread_once</a> (<a class="el" href="structpthread__once__t.html">pthread_once_t</a> *__once_control, void(*__init_routine)(void))
<li><a class="anchor" name="gbcb2ac937cad80b74d9268c6a60dc1eb"></a><!-- doxytag: member="Pthread::pthread_cancel" ref="gbcb2ac937cad80b74d9268c6a60dc1eb" args="(pthread_t th)" -->
int <b>pthread_cancel</b> (<a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> th)
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A POSIX-based threads API. 
<p>
To use this API, include <code>&lt;<a class="el" href="pthread_8h.html" title="Defines the API in the Pthread library.">pthread.h</a>&gt;</code> and link with the <code>pthread</code> library. <hr><h2>Define Documentation</h2>
<a class="anchor" name="gc0b1f67334a9ee234f0754122d55f0ac"></a><!-- doxytag: member="pthread.h::MAX_THREAD_ID" ref="gc0b1f67334a9ee234f0754122d55f0ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_THREAD_ID&nbsp;&nbsp;&nbsp;(0xfffffffe)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum valid thread ID value. 
<p>

</div>
</div><p>
<a class="anchor" name="g30790df7d4c04bece5751a8f55a96635"></a><!-- doxytag: member="pthread.h::NACL_PTHREAD_ILLEGAL_THREAD_ID" ref="g30790df7d4c04bece5751a8f55a96635" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NACL_PTHREAD_ILLEGAL_THREAD_ID&nbsp;&nbsp;&nbsp;(0xffffffff)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Illegal thread ID value. 
<p>

</div>
</div><p>
<a class="anchor" name="g2d3db10a8cc49ec7afef746b09f84d7a"></a><!-- doxytag: member="pthread.h::NC_INVALID_HANDLE" ref="g2d3db10a8cc49ec7afef746b09f84d7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NC_INVALID_HANDLE&nbsp;&nbsp;&nbsp;-1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A value that represents an uninitialized handle. 
<p>

</div>
</div><p>
<a class="anchor" name="ga7b867fe46f3660283fcb356c4fcbbf0"></a><!-- doxytag: member="pthread.h::PTHREAD_COND_INITIALIZER" ref="ga7b867fe46f3660283fcb356c4fcbbf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_COND_INITIALIZER&nbsp;&nbsp;&nbsp;{0, NC_INVALID_HANDLE}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Statically initializes a condition variable (<a class="el" href="structpthread__cond__t.html" title="A structure representing a condition variable.">pthread_cond_t</a>). 
<p>

</div>
</div><p>
<a class="anchor" name="ge96b861c8d74168ee14ef2691a64ff91"></a><!-- doxytag: member="pthread.h::pthread_cond_timedwait" ref="ge96b861c8d74168ee14ef2691a64ff91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pthread_cond_timedwait&nbsp;&nbsp;&nbsp;pthread_cond_timedwait_abs          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defined for POSIX compatibility; <a class="el" href="group___pthread.html#ge96b861c8d74168ee14ef2691a64ff91" title="Defined for POSIX compatibility; pthread_cond_timedwait() is actually a macro calling...">pthread_cond_timedwait()</a> is actually a macro calling <a class="el" href="group___pthread.html#g54b88b0efacf9daf6adfe1c6d2d0d8f2" title="[not quite POSIX] Waits for condition variable cond to be signaled or broadcast until...">pthread_cond_timedwait_abs()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="g391c5eb0f6b5febc48710d0be3f62394"></a><!-- doxytag: member="pthread.h::PTHREAD_CREATE_DETACHED" ref="g391c5eb0f6b5febc48710d0be3f62394" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_CREATE_DETACHED&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detached thread type; for use with <a class="el" href="group___pthread.html#ge6ee78c307d8467b34a9b0c330993a54" title="[not quite POSIX] Sets the detachstate attribute in thread attributes.">pthread_attr_setdetachstate()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="gfb10d234d831c7b57768d62786748bc7"></a><!-- doxytag: member="pthread.h::PTHREAD_CREATE_JOINABLE" ref="gfb10d234d831c7b57768d62786748bc7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_CREATE_JOINABLE&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Joinable thread type; for use with <a class="el" href="group___pthread.html#ge6ee78c307d8467b34a9b0c330993a54" title="[not quite POSIX] Sets the detachstate attribute in thread attributes.">pthread_attr_setdetachstate()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="gcff148607c8534833336adb03d3f7b5b"></a><!-- doxytag: member="pthread.h::PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP" ref="gcff148607c8534833336adb03d3f7b5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP&nbsp;&nbsp;&nbsp;{0, 2, NACL_PTHREAD_ILLEGAL_THREAD_ID, 0, NC_INVALID_HANDLE}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Statically initializes a <a class="el" href="structpthread__mutex__t.html" title="A structure representing a thread mutex.">pthread_mutex_t</a> representing an error-checking mutex. 
<p>

</div>
</div><p>
<a class="anchor" name="g0a23e66e087bcf5c253b9b2746f19a64"></a><!-- doxytag: member="pthread.h::PTHREAD_KEYS_MAX" ref="g0a23e66e087bcf5c253b9b2746f19a64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_KEYS_MAX&nbsp;&nbsp;&nbsp;512          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of available keys for thread-specific data. 
<p>

</div>
</div><p>
<a class="anchor" name="g103cfe33413e92a1c25cb17b943e2edb"></a><!-- doxytag: member="pthread.h::PTHREAD_MUTEX_ERRORCHECK_NP" ref="g103cfe33413e92a1c25cb17b943e2edb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_MUTEX_ERRORCHECK_NP&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Error-checking mutex type; for use with <a class="el" href="group___pthread.html#g4676cf36cad3bde781928419735e6fb7" title="[not quite POSIX] Sets the mutex type: fast, recursive or error-checking.">pthread_mutexattr_settype()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="g19223e28eb0b44c645adf508acf580d6"></a><!-- doxytag: member="pthread.h::PTHREAD_MUTEX_FAST_NP" ref="g19223e28eb0b44c645adf508acf580d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_MUTEX_FAST_NP&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast mutex type; for use with <a class="el" href="group___pthread.html#g4676cf36cad3bde781928419735e6fb7" title="[not quite POSIX] Sets the mutex type: fast, recursive or error-checking.">pthread_mutexattr_settype()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="g84e55100366a6a8338a2af3b3f279686"></a><!-- doxytag: member="pthread.h::PTHREAD_MUTEX_INITIALIZER" ref="g84e55100366a6a8338a2af3b3f279686" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_MUTEX_INITIALIZER&nbsp;&nbsp;&nbsp;{0, 0, NACL_PTHREAD_ILLEGAL_THREAD_ID, 0, NC_INVALID_HANDLE}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Statically initializes a <a class="el" href="structpthread__mutex__t.html" title="A structure representing a thread mutex.">pthread_mutex_t</a> representing a fast mutex. 
<p>

</div>
</div><p>
<a class="anchor" name="g24a251d355bd6ed4c72963740a579cc5"></a><!-- doxytag: member="pthread.h::PTHREAD_MUTEX_RECURSIVE_NP" ref="g24a251d355bd6ed4c72963740a579cc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_MUTEX_RECURSIVE_NP&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursive mutex type; for use with <a class="el" href="group___pthread.html#g4676cf36cad3bde781928419735e6fb7" title="[not quite POSIX] Sets the mutex type: fast, recursive or error-checking.">pthread_mutexattr_settype()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="g59e22497b65fc305ddb5cea8b4990b51"></a><!-- doxytag: member="pthread.h::PTHREAD_ONCE_INIT" ref="g59e22497b65fc305ddb5cea8b4990b51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_ONCE_INIT&nbsp;&nbsp;&nbsp;{0, PTHREAD_MUTEX_INITIALIZER}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static initializer for <a class="el" href="structpthread__once__t.html" title="A structure describing a control block used with the pthread_once() function.">pthread_once_t</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="gc2663553b072167a403521db5b4e82c4"></a><!-- doxytag: member="pthread.h::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP" ref="gc2663553b072167a403521db5b4e82c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP&nbsp;&nbsp;&nbsp;{0, 1, NACL_PTHREAD_ILLEGAL_THREAD_ID, 0, NC_INVALID_HANDLE}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Statically initializes a <a class="el" href="structpthread__mutex__t.html" title="A structure representing a thread mutex.">pthread_mutex_t</a> representing a recursive mutex. 
<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g5e5de7274261aeace765f3dff906b76a"></a><!-- doxytag: member="pthread.h::nc_thread_function" ref="g5e5de7274261aeace765f3dff906b76a" args=")(void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* <a class="el" href="group___pthread.html#g5e5de7274261aeace765f3dff906b76a">nc_thread_function</a>)(void *p)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread entry function type. 
<p>

</div>
</div><p>
<a class="anchor" name="g3b04e4ea6b20411bbfccd3b85a536dcb"></a><!-- doxytag: member="pthread.h::pthread_key_t" ref="g3b04e4ea6b20411bbfccd3b85a536dcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread-specific key identifier type. 
<p>

</div>
</div><p>
<a class="anchor" name="g405938c67e9c568fde9993c7e14d58ec"></a><!-- doxytag: member="pthread.h::pthread_t" ref="g405938c67e9c568fde9993c7e14d58ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread identifier type. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g6a65d6ba3fc51aa5e30ef225307fb1bb"></a><!-- doxytag: member="pthread.h::nacl_thread_nice" ref="g6a65d6ba3fc51aa5e30ef225307fb1bb" args="(const int nice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nacl_thread_nice           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nice</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Indicates that the calling thread is to receive special consideration by the scheduler as indicated by parameter nice. 
<p>
Suggested values are NICE_REALTIME, NICE_NORMAL, NICE_BACKGROUND, defined above. The implementation of this subroutine is platform-specific. Implementations should respect the sign of the nice parameter, and may respect the magnitude.<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nice</em>&nbsp;</td><td>Nice value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4bcdbf47c17c7dcc51e9f05f5cb56d81"></a><!-- doxytag: member="pthread.h::pthread_attr_destroy" ref="g4bcdbf47c17c7dcc51e9f05f5cb56d81" args="(pthread_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_attr_destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Destroys a thread attributes structure. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to thread attributes structure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc97de7a8a6d460109843215a81a52f7c"></a><!-- doxytag: member="pthread.h::pthread_attr_getdetachstate" ref="gc97de7a8a6d460109843215a81a52f7c" args="(pthread_attr_t *attr, int *detachstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_attr_getdetachstate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>detachstate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Gets the detachstate attribute from thread attributes. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to thread attributes structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detachstate</em>&nbsp;</td><td>Location where the value of `detachstate` is stored upon successful completion.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0b85ebb1e3aac081a4c0a5e85ae3cbe9"></a><!-- doxytag: member="pthread.h::pthread_attr_init" ref="g0b85ebb1e3aac081a4c0a5e85ae3cbe9" args="(pthread_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_attr_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Initializes thread attributes structure attr with default attributes (detachstate is PTHREAD_CREATE_JOINABLE). 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to thread attributes structure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge6ee78c307d8467b34a9b0c330993a54"></a><!-- doxytag: member="pthread.h::pthread_attr_setdetachstate" ref="ge6ee78c307d8467b34a9b0c330993a54" args="(pthread_attr_t *attr, int detachstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_attr_setdetachstate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detachstate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Sets the detachstate attribute in thread attributes. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to thread attributes structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detachstate</em>&nbsp;</td><td>Value to be set, determines whether the thread is joinable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfc4b19aa8ea2dce0956579ce878b4998"></a><!-- doxytag: member="pthread.h::pthread_cond_broadcast" ref="gfc4b19aa8ea2dce0956579ce878b4998" args="(pthread_cond_t *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_broadcast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Wakes up all threads waiting on a condition variable. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga1587e01856a579b78effd0a1a284a47"></a><!-- doxytag: member="pthread.h::pthread_cond_destroy" ref="ga1587e01856a579b78effd0a1a284a47" args="(pthread_cond_t *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Destroys a condition variable. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g46e1d6e885975dee1a31339a08bf09be"></a><!-- doxytag: member="pthread.h::pthread_cond_init" ref="g46e1d6e885975dee1a31339a08bf09be" args="(pthread_cond_t *cond, pthread_condattr_t *cond_attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpthread__condattr__t.html">pthread_condattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond_attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Initializes a condition variable. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cond_attr</em>&nbsp;</td><td>Pointer to the attributes structure, should be NULL as Native Client does not support any attributes for a condition variable at this stage.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, 1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g20f98235b024efb10e5c76a64f0d94e5"></a><!-- doxytag: member="pthread.h::pthread_cond_signal" ref="g20f98235b024efb10e5c76a64f0d94e5" args="(pthread_cond_t *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_signal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Signals a condition variable, waking up one of the threads waiting on it. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g54b88b0efacf9daf6adfe1c6d2d0d8f2"></a><!-- doxytag: member="pthread.h::pthread_cond_timedwait_abs" ref="g54b88b0efacf9daf6adfe1c6d2d0d8f2" args="(pthread_cond_t *cond, pthread_mutex_t *mutex, struct timespec *abstime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_timedwait_abs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>abstime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Waits for condition variable cond to be signaled or broadcast until abstime. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>Pointer to the mutex structure. The mutex is assumed to be locked when this function is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abstime</em>&nbsp;</td><td>Absolute time specification; zero is the beginning of the epoch (00:00:00 GMT, January 1, 1970).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd6871806d633bce2f65b49b5ac8557dc"></a><!-- doxytag: member="pthread.h::pthread_cond_timedwait_rel" ref="gd6871806d633bce2f65b49b5ac8557dc" args="(pthread_cond_t *cond, pthread_mutex_t *mutex, struct timespec *reltime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_timedwait_rel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>reltime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Waits for condition variable cond to be signaled or broadcast; wait time is limited by reltime. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>Pointer to the mutex structure. The mutex is assumed to be locked when this function is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reltime</em>&nbsp;</td><td>Time specification, relative to the current time.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g907ae104b6dfd8fc12e23e84952aa7ca"></a><!-- doxytag: member="pthread.h::pthread_cond_wait" ref="g907ae104b6dfd8fc12e23e84952aa7ca" args="(pthread_cond_t *cond, pthread_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_cond_wait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__cond__t.html">pthread_cond_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Waits for a condition variable to be signaled or broadcast. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Pointer to the condition variable structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>Pointer to the mutex structure. The mutex is assumed to be locked when this function is called.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb4643e8af2b936d971d3248ec70507e1"></a><!-- doxytag: member="pthread.h::pthread_create" ref="gb4643e8af2b936d971d3248ec70507e1" args="(pthread_t *thread_id, pthread_attr_t *attr, void *(*start_routine)(void *p), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpthread__attr__t.html">pthread_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *p)&nbsp;</td>
          <td class="paramname"> <em>start_routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Creates a thread. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>thread_id</em>&nbsp;</td><td>A pointer to the location where the identifier of the newly created thread is stored on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Thread attributes structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_routine</em>&nbsp;</td><td>Thread function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>A single argument that is passed to the thread function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g28a542ad2b8f7e58cc102a599c556b4a"></a><!-- doxytag: member="pthread.h::pthread_detach" ref="g28a542ad2b8f7e58cc102a599c556b4a" args="(pthread_t th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_detach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a>&nbsp;</td>
          <td class="paramname"> <em>th</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Indicates that the specified thread is never to be joined with <a class="el" href="group___pthread.html#ga98e330a54fc8c376b4b7bc5121e8513" title="[not quite POSIX] Makes the calling thread wait for termination of another thread...">pthread_join()</a>. 
<p>
The resources of that thread will therefore be freed immediately when it terminates, instead of waiting for another thread to perform <a class="el" href="group___pthread.html#ga98e330a54fc8c376b4b7bc5121e8513" title="[not quite POSIX] Makes the calling thread wait for termination of another thread...">pthread_join()</a> on it.<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>Thread identifier.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g62b59b2f2765bba485afc979e6e24c9a"></a><!-- doxytag: member="pthread.h::pthread_equal" ref="g62b59b2f2765bba485afc979e6e24c9a" args="(pthread_t thread1, pthread_t thread2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_equal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a>&nbsp;</td>
          <td class="paramname"> <em>thread1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a>&nbsp;</td>
          <td class="paramname"> <em>thread2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Compares two thread identifiers. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread1</em>&nbsp;</td><td>Thread ID of thread A. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread2</em>&nbsp;</td><td>Thread ID of thread B.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if both identifiers belong to the same thread, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g23b28e0f8ac5af2b46a33cdab3a80e44"></a><!-- doxytag: member="pthread.h::pthread_exit" ref="g23b28e0f8ac5af2b46a33cdab3a80e44" args="(void *retval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread_exit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>retval</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Terminates the calling thread. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>retval</em>&nbsp;</td><td>Return value of the thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The function never returns. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g31469375891078185bda93f0e4411a2c"></a><!-- doxytag: member="pthread.h::pthread_getspecific" ref="g31469375891078185bda93f0e4411a2c" args="(pthread_key_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pthread_getspecific           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Gets the value currently stored at the thread-specific data slot identified by the key. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key value, previously obtained using <a class="el" href="group___pthread.html#gb4a3d557336099397ec0baf627a88e61" title="[not quite POSIX] Creates a key value identifying a location in the thread-specific...">pthread_key_create()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value that was previously stored using pthread_setspecific is returned on success, otherwise NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga98e330a54fc8c376b4b7bc5121e8513"></a><!-- doxytag: member="pthread.h::pthread_join" ref="ga98e330a54fc8c376b4b7bc5121e8513" args="(pthread_t th, void **thread_return)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_join           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a>&nbsp;</td>
          <td class="paramname"> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>thread_return</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Makes the calling thread wait for termination of another thread. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The identifier of the thread to wait for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_return</em>&nbsp;</td><td>If not NULL, points to the location where the return value of the terminated thread is stored upon completion.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb4a3d557336099397ec0baf627a88e61"></a><!-- doxytag: member="pthread.h::pthread_key_create" ref="gb4a3d557336099397ec0baf627a88e61" args="(pthread_key_t *key, void(*destr_function)(void *p))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_key_create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *p)&nbsp;</td>
          <td class="paramname"> <em>destr_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Creates a key value identifying a location in the thread-specific data area. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Pointer to the location where the value of the key is stored upon successful completion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destr_function</em>&nbsp;</td><td>Pointer to a cleanup function that is called if the thread terminates while the key is still allocated.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gee96306dc79294927ee840bb4de2244b"></a><!-- doxytag: member="pthread.h::pthread_key_delete" ref="gee96306dc79294927ee840bb4de2244b" args="(pthread_key_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_key_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Destroys a thread-specific data key. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key value, previously obtained using <a class="el" href="group___pthread.html#gb4a3d557336099397ec0baf627a88e61" title="[not quite POSIX] Creates a key value identifying a location in the thread-specific...">pthread_key_create()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3cf620ff3a40af11d79cf28901dc55e2"></a><!-- doxytag: member="pthread.h::pthread_mutex_destroy" ref="g3cf620ff3a40af11d79cf28901dc55e2" args="(pthread_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Destroys a mutex. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of the mutex structure to be destroyed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 upon success, non-zero error code otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7c40d08c34d2416ffa1ab8436757a92f"></a><!-- doxytag: member="pthread.h::pthread_mutex_init" ref="g7c40d08c34d2416ffa1ab8436757a92f" args="(pthread_mutex_t *mutex, pthread_mutexattr_t *mutex_attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex_attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Initializes a mutex using attributes in mutex_attr, or using the default values if the latter is NULL. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of the mutex structure to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex_attr</em>&nbsp;</td><td>The address of the attributes structure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 upon success, 1 otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="g12809c44718c21544ceb280dc1a53573"></a><!-- doxytag: member="pthread.h::pthread_mutex_lock" ref="g12809c44718c21544ceb280dc1a53573" args="(pthread_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_lock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Locks a mutex. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of the mutex structure to be locked.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 upon success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g27da386211db1a7e9a3b2a0db4d22144"></a><!-- doxytag: member="pthread.h::pthread_mutex_trylock" ref="g27da386211db1a7e9a3b2a0db4d22144" args="(pthread_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_trylock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Tries to lock a mutex. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of the mutex structure to be locked.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 upon success, EBUSY if the mutex is locked by another thread, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g96184290ffb60e04c53a52869cf960a2"></a><!-- doxytag: member="pthread.h::pthread_mutex_unlock" ref="g96184290ffb60e04c53a52869cf960a2" args="(pthread_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_unlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutex__t.html">pthread_mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Unlocks a mutex. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of the mutex structure to be unlocked.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 upon success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2321aabf58224b06021185708d0f9658"></a><!-- doxytag: member="pthread.h::pthread_mutexattr_destroy" ref="g2321aabf58224b06021185708d0f9658" args="(pthread_mutexattr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Destroys mutex attributes structure. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The address of the attributes structure to be destroyed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb095da0afa402ababcdc75b77e3ce2a8"></a><!-- doxytag: member="pthread.h::pthread_mutexattr_gettype" ref="gb095da0afa402ababcdc75b77e3ce2a8" args="(const pthread_mutexattr_t *attr, int *kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_gettype           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Gets the mutex type: fast, recursive or error-checking. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The address of the attributes structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Pointer to the location where the mutex kind value is copied.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf98f6b6c483077a39d1400b1de1577b8"></a><!-- doxytag: member="pthread.h::pthread_mutexattr_init" ref="gf98f6b6c483077a39d1400b1de1577b8" args="(pthread_mutexattr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Initializes mutex attributes. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The address of the attributes structure to be initialized.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4676cf36cad3bde781928419735e6fb7"></a><!-- doxytag: member="pthread.h::pthread_mutexattr_settype" ref="g4676cf36cad3bde781928419735e6fb7" args="(pthread_mutexattr_t *attr, int kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_settype           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__mutexattr__t.html">pthread_mutexattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Sets the mutex type: fast, recursive or error-checking. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The address of the attributes structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>PTHREAD_MUTEX_FAST_NP, PTHREAD_MUTEX_RECURSIVE_NP or PTHREAD_MUTEX_ERRORCHECK_NP.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, -1 for illegal values of kind. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3107d6f08955edec3467e2a01c668eb4"></a><!-- doxytag: member="pthread.h::pthread_once" ref="g3107d6f08955edec3467e2a01c668eb4" args="(pthread_once_t *__once_control, void(*__init_routine)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_once           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpthread__once__t.html">pthread_once_t</a> *&nbsp;</td>
          <td class="paramname"> <em>__once_control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>__init_routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Ensures that a piece of initialization code is executed at most once. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>__once_control</em>&nbsp;</td><td>Points to a static or extern variable statically initialized to PTHREAD_ONCE_INIT. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__init_routine</em>&nbsp;</td><td>A pointer to the initialization function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4c4f5f3b4f8f45d9d897847d53b11aaa"></a><!-- doxytag: member="pthread.h::pthread_self" ref="g4c4f5f3b4f8f45d9d897847d53b11aaa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___pthread.html#g405938c67e9c568fde9993c7e14d58ec">pthread_t</a> pthread_self           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Obtains the identifier of the current thread. 
<p>
Requires linking with pthread library.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Thread ID of the current thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc4a911634124e77dd075b1976712e801"></a><!-- doxytag: member="pthread.h::pthread_setspecific" ref="gc4a911634124e77dd075b1976712e801" args="(pthread_key_t key, const void *pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_setspecific           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pthread.html#g3b04e4ea6b20411bbfccd3b85a536dcb">pthread_key_t</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[not quite POSIX] Stores a value in the thread-specific data slot identified by a key value. 
<p>
Requires linking with pthread library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key value, previously obtained using <a class="el" href="group___pthread.html#gb4a3d557336099397ec0baf627a88e61" title="[not quite POSIX] Creates a key value identifying a location in the thread-specific...">pthread_key_create()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>The value to be stored.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero error code otherwise. </dd></dl>

</div>
</div><p>
</div>
    <p id="license">
    Except as otherwise
    <a href="http://code.google.com/policies.html#restrictions">noted</a>,
    the content of this page is licensed under a
    <a href="http://www.google.com/url?sa=D&amp;q=http%3A%2F%2Fcreativecommons.org/licenses/by/2.5/">Creative Commons
    Attribution 2.5 license</a>.
    </p>

    <address>
    &copy;2009 Google
    </address>

    <address>
    Generated 29 Oct 2009 by
    <a href="http://www.doxygen.org/index.html">doxygen</a> 1.5.7.1
    </address>

  </body>
</html>
